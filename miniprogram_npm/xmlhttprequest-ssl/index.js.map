{"version":3,"sources":["XMLHttpRequest.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\r\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\r\n *\r\n * This can be used with JS designed for browsers to improve reuse of code and\r\n * allow the use of existing libraries.\r\n *\r\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\r\n *\r\n * @author Dan DeFelippi <dan@driverdan.com>\r\n * @contributor David Ellis <d.f.ellis@ieee.org>\r\n * @license MIT\r\n */\r\n\r\nvar fs = require('fs');\r\nvar Url = require('url');\r\nvar spawn = require('child_process').spawn;\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = XMLHttpRequest;\r\n\r\n// backwards-compat\r\nXMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\r\n\r\n/**\r\n * `XMLHttpRequest` constructor.\r\n *\r\n * Supported options for the `opts` object are:\r\n *\r\n *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled\r\n *\r\n * @param {Object} opts optional \"options\" object\r\n */\r\n\r\nfunction XMLHttpRequest(opts) {\r\n  \r\n\r\n  opts = opts || {};\r\n\r\n  /**\r\n   * Private variables\r\n   */\r\n  var self = this;\r\n  var http = require('http');\r\n  var https = require('https');\r\n\r\n  // Holds http.js objects\r\n  var request;\r\n  var response;\r\n\r\n  // Request settings\r\n  var settings = {};\r\n\r\n  // Disable header blacklist.\r\n  // Not part of XHR specs.\r\n  var disableHeaderCheck = false;\r\n\r\n  // Set some default headers\r\n  var defaultHeaders = {\r\n    \"User-Agent\": \"node-XMLHttpRequest\",\r\n    \"Accept\": \"*/*\"\r\n  };\r\n\r\n  var headers = Object.assign({}, defaultHeaders);\r\n\r\n  // These headers are not user setable.\r\n  // The following are allowed but banned in the spec:\r\n  // * user-agent\r\n  var forbiddenRequestHeaders = [\r\n    \"accept-charset\",\r\n    \"accept-encoding\",\r\n    \"access-control-request-headers\",\r\n    \"access-control-request-method\",\r\n    \"connection\",\r\n    \"content-length\",\r\n    \"content-transfer-encoding\",\r\n    \"cookie\",\r\n    \"cookie2\",\r\n    \"date\",\r\n    \"expect\",\r\n    \"host\",\r\n    \"keep-alive\",\r\n    \"origin\",\r\n    \"referer\",\r\n    \"te\",\r\n    \"trailer\",\r\n    \"transfer-encoding\",\r\n    \"upgrade\",\r\n    \"via\"\r\n  ];\r\n\r\n  // These request methods are not allowed\r\n  var forbiddenRequestMethods = [\r\n    \"TRACE\",\r\n    \"TRACK\",\r\n    \"CONNECT\"\r\n  ];\r\n\r\n  // Send flag\r\n  var sendFlag = false;\r\n  // Error flag, used when errors occur or abort is called\r\n  var errorFlag = false;\r\n\r\n  // Event listeners\r\n  var listeners = {};\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  this.UNSENT = 0;\r\n  this.OPENED = 1;\r\n  this.HEADERS_RECEIVED = 2;\r\n  this.LOADING = 3;\r\n  this.DONE = 4;\r\n\r\n  /**\r\n   * Public vars\r\n   */\r\n\r\n  // Current state\r\n  this.readyState = this.UNSENT;\r\n\r\n  // default ready state change handler in case one is not set or is set late\r\n  this.onreadystatechange = null;\r\n\r\n  // Result & response\r\n  this.responseText = \"\";\r\n  this.responseXML = \"\";\r\n  this.status = null;\r\n  this.statusText = null;\r\n\r\n  /**\r\n   * Private methods\r\n   */\r\n\r\n  /**\r\n   * Check if the specified header is allowed.\r\n   *\r\n   * @param string header Header to validate\r\n   * @return boolean False if not allowed, otherwise true\r\n   */\r\n  var isAllowedHttpHeader = function(header) {\r\n    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);\r\n  };\r\n\r\n  /**\r\n   * Check if the specified method is allowed.\r\n   *\r\n   * @param string method Request method to validate\r\n   * @return boolean False if not allowed, otherwise true\r\n   */\r\n  var isAllowedHttpMethod = function(method) {\r\n    return (method && forbiddenRequestMethods.indexOf(method) === -1);\r\n  };\r\n\r\n  /**\r\n   * Public methods\r\n   */\r\n\r\n  /**\r\n   * Open the connection. Currently supports local server requests.\r\n   *\r\n   * @param string method Connection method (eg GET, POST)\r\n   * @param string url URL for the connection.\r\n   * @param boolean async Asynchronous connection. Default is true.\r\n   * @param string user Username for basic authentication (optional)\r\n   * @param string password Password for basic authentication (optional)\r\n   */\r\n  this.open = function(method, url, async, user, password) {\r\n    this.abort();\r\n    errorFlag = false;\r\n\r\n    // Check for valid request method\r\n    if (!isAllowedHttpMethod(method)) {\r\n      throw \"SecurityError: Request method not allowed\";\r\n    }\r\n\r\n    settings = {\r\n      \"method\": method,\r\n      \"url\": url.toString(),\r\n      \"async\": (typeof async !== \"boolean\" ? true : async),\r\n      \"user\": user || null,\r\n      \"password\": password || null\r\n    };\r\n\r\n    setState(this.OPENED);\r\n  };\r\n\r\n  /**\r\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\r\n   * This does not conform to the W3C spec.\r\n   *\r\n   * @param boolean state Enable or disable header checking.\r\n   */\r\n  this.setDisableHeaderCheck = function(state) {\r\n    disableHeaderCheck = state;\r\n  };\r\n\r\n  /**\r\n   * Sets a header for the request.\r\n   *\r\n   * @param string header Header name\r\n   * @param string value Header value\r\n   * @return boolean Header added\r\n   */\r\n  this.setRequestHeader = function(header, value) {\r\n    if (this.readyState != this.OPENED) {\r\n      throw \"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\";\r\n      return false;\r\n    }\r\n    if (!isAllowedHttpHeader(header)) {\r\n      console.warn('Refused to set unsafe header \"' + header + '\"');\r\n      return false;\r\n    }\r\n    if (sendFlag) {\r\n      throw \"INVALID_STATE_ERR: send flag is true\";\r\n      return false;\r\n    }\r\n    headers[header] = value;\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Gets a header from the server response.\r\n   *\r\n   * @param string header Name of header to get.\r\n   * @return string Text of the header or null if it doesn't exist.\r\n   */\r\n  this.getResponseHeader = function(header) {\r\n    if (typeof header === \"string\"\r\n      && this.readyState > this.OPENED\r\n      && response.headers[header.toLowerCase()]\r\n      && !errorFlag\r\n    ) {\r\n      return response.headers[header.toLowerCase()];\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Gets all the response headers.\r\n   *\r\n   * @return string A string with all response headers separated by CR+LF\r\n   */\r\n  this.getAllResponseHeaders = function() {\r\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\r\n      return \"\";\r\n    }\r\n    var result = \"\";\r\n\r\n    for (var i in response.headers) {\r\n      // Cookie headers are excluded\r\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\r\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\r\n      }\r\n    }\r\n    return result.substr(0, result.length - 2);\r\n  };\r\n\r\n  /**\r\n   * Gets a request header\r\n   *\r\n   * @param string name Name of header to get\r\n   * @return string Returns the request header or empty string if not set\r\n   */\r\n  this.getRequestHeader = function(name) {\r\n    // @TODO Make this case insensitive\r\n    if (typeof name === \"string\" && headers[name]) {\r\n      return headers[name];\r\n    }\r\n\r\n    return \"\";\r\n  };\r\n\r\n  /**\r\n   * Sends the request to the server.\r\n   *\r\n   * @param string data Optional data to send as request body.\r\n   */\r\n  this.send = function(data) {\r\n    if (this.readyState != this.OPENED) {\r\n      throw \"INVALID_STATE_ERR: connection must be opened before send() is called\";\r\n    }\r\n\r\n    if (sendFlag) {\r\n      throw \"INVALID_STATE_ERR: send has already been called\";\r\n    }\r\n\r\n    var ssl = false, local = false;\r\n    var url = Url.parse(settings.url);\r\n    var host;\r\n    // Determine the server\r\n    switch (url.protocol) {\r\n      case 'https:':\r\n        ssl = true;\r\n        // SSL & non-SSL both need host, no break here.\r\n      case 'http:':\r\n        host = url.hostname;\r\n        break;\r\n\r\n      case 'file:':\r\n        local = true;\r\n        break;\r\n\r\n      case undefined:\r\n      case '':\r\n        host = \"localhost\";\r\n        break;\r\n\r\n      default:\r\n        throw \"Protocol not supported.\";\r\n    }\r\n\r\n    // Load files off the local filesystem (file://)\r\n    if (local) {\r\n      if (settings.method !== \"GET\") {\r\n        throw \"XMLHttpRequest: Only GET method is supported\";\r\n      }\r\n\r\n      if (settings.async) {\r\n        fs.readFile(url.pathname, 'utf8', function(error, data) {\r\n          if (error) {\r\n            self.handleError(error);\r\n          } else {\r\n            self.status = 200;\r\n            self.responseText = data;\r\n            setState(self.DONE);\r\n          }\r\n        });\r\n      } else {\r\n        try {\r\n          this.responseText = fs.readFileSync(url.pathname, 'utf8');\r\n          this.status = 200;\r\n          setState(self.DONE);\r\n        } catch(e) {\r\n          this.handleError(e);\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // Default to port 80. If accessing localhost on another port be sure\r\n    // to use http://localhost:port/path\r\n    var port = url.port || (ssl ? 443 : 80);\r\n    // Add query string if one is used\r\n    var uri = url.pathname + (url.search ? url.search : '');\r\n\r\n    // Set the Host header or the server may reject the request\r\n    headers[\"Host\"] = host;\r\n    if (!((ssl && port === 443) || port === 80)) {\r\n      headers[\"Host\"] += ':' + url.port;\r\n    }\r\n\r\n    // Set Basic Auth if necessary\r\n    if (settings.user) {\r\n      if (typeof settings.password == \"undefined\") {\r\n        settings.password = \"\";\r\n      }\r\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\r\n      headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\r\n    }\r\n\r\n    // Set content length header\r\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\r\n      data = null;\r\n    } else if (data) {\r\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\r\n\r\n      if (!headers[\"Content-Type\"]) {\r\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\r\n      }\r\n    } else if (settings.method === \"POST\") {\r\n      // For a post with no data set Content-Length: 0.\r\n      // This is required by buggy servers that don't meet the specs.\r\n      headers[\"Content-Length\"] = 0;\r\n    }\r\n\r\n    var agent = opts.agent || false;\r\n    var options = {\r\n      host: host,\r\n      port: port,\r\n      path: uri,\r\n      method: settings.method,\r\n      headers: headers,\r\n      agent: agent\r\n    };\r\n\r\n    if (ssl) {\r\n      options.pfx = opts.pfx;\r\n      options.key = opts.key;\r\n      options.passphrase = opts.passphrase;\r\n      options.cert = opts.cert;\r\n      options.ca = opts.ca;\r\n      options.ciphers = opts.ciphers;\r\n      options.rejectUnauthorized = opts.rejectUnauthorized;\r\n    }\r\n\r\n    // Reset error flag\r\n    errorFlag = false;\r\n\r\n    // Handle async requests\r\n    if (settings.async) {\r\n      // Use the proper protocol\r\n      var doRequest = ssl ? https.request : http.request;\r\n\r\n      // Request is being sent, set send flag\r\n      sendFlag = true;\r\n\r\n      // As per spec, this is called here for historical reasons.\r\n      self.dispatchEvent(\"readystatechange\");\r\n\r\n      // Handler for the response\r\n      var responseHandler = function(resp) {\r\n        // Set response var to the response we got back\r\n        // This is so it remains accessable outside this scope\r\n        response = resp;\r\n        // Check for redirect\r\n        // @TODO Prevent looped redirects\r\n        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\r\n          // Change URL to the redirect location\r\n          settings.url = response.headers.location;\r\n          var url = Url.parse(settings.url);\r\n          // Set host var in case it's used later\r\n          host = url.hostname;\r\n          // Options for the new request\r\n          var newOptions = {\r\n            hostname: url.hostname,\r\n            port: url.port,\r\n            path: url.path,\r\n            method: response.statusCode === 303 ? 'GET' : settings.method,\r\n            headers: headers\r\n          };\r\n\r\n          if (ssl) {\r\n            newOptions.pfx = opts.pfx;\r\n            newOptions.key = opts.key;\r\n            newOptions.passphrase = opts.passphrase;\r\n            newOptions.cert = opts.cert;\r\n            newOptions.ca = opts.ca;\r\n            newOptions.ciphers = opts.ciphers;\r\n            newOptions.rejectUnauthorized = opts.rejectUnauthorized;\r\n          }\r\n\r\n          // Issue the new request\r\n          request = doRequest(newOptions, responseHandler).on('error', errorHandler);\r\n          request.end();\r\n          // @TODO Check if an XHR event needs to be fired here\r\n          return;\r\n        }\r\n\r\n        if (response && response.setEncoding) {\r\n          response.setEncoding(\"utf8\");\r\n        }\r\n\r\n        setState(self.HEADERS_RECEIVED);\r\n        self.status = response.statusCode;\r\n\r\n        response.on('data', function(chunk) {\r\n          // Make sure there's some data\r\n          if (chunk) {\r\n            self.responseText += chunk;\r\n          }\r\n          // Don't emit state changes if the connection has been aborted.\r\n          if (sendFlag) {\r\n            setState(self.LOADING);\r\n          }\r\n        });\r\n\r\n        response.on('end', function() {\r\n          if (sendFlag) {\r\n            // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks\r\n            // there can be a timing issue (the callback is called and a new call is made before the flag is reset).\r\n            sendFlag = false;\r\n            // Discard the 'end' event if the connection has been aborted\r\n            setState(self.DONE);\r\n          }\r\n        });\r\n\r\n        response.on('error', function(error) {\r\n          self.handleError(error);\r\n        });\r\n      }\r\n\r\n      // Error handler for the request\r\n      var errorHandler = function(error) {\r\n        self.handleError(error);\r\n      }\r\n\r\n      // Create the request\r\n      request = doRequest(options, responseHandler).on('error', errorHandler);\r\n\r\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\r\n      if (data) {\r\n        request.write(data);\r\n      }\r\n\r\n      request.end();\r\n\r\n      self.dispatchEvent(\"loadstart\");\r\n    } else { // Synchronous\r\n      // Create a temporary file for communication with the other Node process\r\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\r\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\r\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\r\n      // The async request the other Node process executes\r\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\"\r\n        + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\"\r\n        + \"var options = \" + JSON.stringify(options) + \";\"\r\n        + \"var responseText = '';\"\r\n        + \"var req = doRequest(options, function(response) {\"\r\n        + \"response.setEncoding('utf8');\"\r\n        + \"response.on('data', function(chunk) {\"\r\n        + \"  responseText += chunk;\"\r\n        + \"});\"\r\n        + \"response.on('end', function() {\"\r\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');\"\r\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\r\n        + \"});\"\r\n        + \"response.on('error', function(error) {\"\r\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\r\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\r\n        + \"});\"\r\n        + \"}).on('error', function(error) {\"\r\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\r\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\r\n        + \"});\"\r\n        + (data ? \"req.write('\" + data.replace(/'/g, \"\\\\'\") + \"');\":\"\")\r\n        + \"req.end();\";\r\n      // Start the other Node Process, executing this string\r\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\r\n      var statusText;\r\n      while(fs.existsSync(syncFile)) {\r\n        // Wait while the sync file is empty\r\n      }\r\n      self.responseText = fs.readFileSync(contentFile, 'utf8');\r\n      // Kill the child process once the file has data\r\n      syncProc.stdin.end();\r\n      // Remove the temporary file\r\n      fs.unlinkSync(contentFile);\r\n      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\r\n        // If the file returned an error, handle it\r\n        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\");\r\n        self.handleError(errorObj);\r\n      } else {\r\n        // If the file returned okay, parse its data and move to the DONE state\r\n        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, \"$1\");\r\n        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, \"$1\");\r\n        setState(self.DONE);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when an error is encountered to deal with it.\r\n   */\r\n  this.handleError = function(error) {\r\n    this.status = 503;\r\n    this.statusText = error;\r\n    this.responseText = error.stack;\r\n    errorFlag = true;\r\n    setState(this.DONE);\r\n  };\r\n\r\n  /**\r\n   * Aborts a request.\r\n   */\r\n  this.abort = function() {\r\n    if (request) {\r\n      request.abort();\r\n      request = null;\r\n    }\r\n\r\n    headers = Object.assign({}, defaultHeaders);\r\n    this.responseText = \"\";\r\n    this.responseXML = \"\";\r\n\r\n    errorFlag = true;\r\n\r\n    if (this.readyState !== this.UNSENT\r\n        && (this.readyState !== this.OPENED || sendFlag)\r\n        && this.readyState !== this.DONE) {\r\n      sendFlag = false;\r\n      setState(this.DONE);\r\n    }\r\n    this.readyState = this.UNSENT;\r\n  };\r\n\r\n  /**\r\n   * Adds an event listener. Preferred method of binding to events.\r\n   */\r\n  this.addEventListener = function(event, callback) {\r\n    if (!(event in listeners)) {\r\n      listeners[event] = [];\r\n    }\r\n    // Currently allows duplicate callbacks. Should it?\r\n    listeners[event].push(callback);\r\n  };\r\n\r\n  /**\r\n   * Remove an event callback that has already been bound.\r\n   * Only works on the matching funciton, cannot be a copy.\r\n   */\r\n  this.removeEventListener = function(event, callback) {\r\n    if (event in listeners) {\r\n      // Filter will return a new array with the callback removed\r\n      listeners[event] = listeners[event].filter(function(ev) {\r\n        return ev !== callback;\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\r\n   */\r\n  this.dispatchEvent = function(event) {\r\n    if (typeof self[\"on\" + event] === \"function\") {\r\n      self[\"on\" + event]();\r\n    }\r\n    if (event in listeners) {\r\n      for (var i = 0, len = listeners[event].length; i < len; i++) {\r\n        listeners[event][i].call(self);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Changes readyState and calls onreadystatechange.\r\n   *\r\n   * @param int state New state\r\n   */\r\n  var setState = function(state) {\r\n    if (self.readyState !== state) {\r\n      self.readyState = state;\r\n\r\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\r\n        self.dispatchEvent(\"readystatechange\");\r\n      }\r\n\r\n      if (self.readyState === self.DONE && !errorFlag) {\r\n        self.dispatchEvent(\"load\");\r\n        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\r\n        self.dispatchEvent(\"loadend\");\r\n      }\r\n    }\r\n  };\r\n};\r\n"]}