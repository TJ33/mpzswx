{"version":3,"sources":["index.js","lib\\WebSocket.js","lib\\PerMessageDeflate.js","lib\\BufferUtil.js","lib\\bufferutil.js","lib\\EventTarget.js","lib\\Extensions.js","lib\\Constants.js","lib\\Receiver.js","lib\\Validation.js","lib\\ErrorCodes.js","lib\\Sender.js","lib\\WebSocketServer.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA,AGTA;AJaA,AGTA,ADGA,ADGA,AGTA;AJaA,AGTA,ADGA,ADGA,AGTA;AJaA,AGTA,AENA,AHSA,ADGA,AGTA;ADIA,AENA,AHSA,ADGA,AGTA;ADIA,AENA,AHSA,ADGA,AGTA;ADIA,AENA,ACHA,AJYA,ADGA,AGTA;ADIA,AENA,ACHA,AJYA,ADGA,AGTA;ADIA,AENA,ACHA,AJYA,ADGA,AGTA;ADIA,AIZA,AFMA,ACHA,AJYA,ADGA,AGTA;ADIA,AIZA,AFMA,ACHA,AJYA,ADGA,AGTA;ADIA,AIZA,AFMA,ACHA,AJYA,ADGA,AGTA;ADIA,AIZA,AFMA,ACHA,AJYA,AMlBA,APqBA,AGTA;ADIA,AIZA,AFMA,ACHA,AJYA,AMlBA,APqBA,AGTA;ADIA,AIZA,AFMA,ACHA,AJYA,AMlBA,APqBA,AGTA;ADIA,AIZA,AFMA,ACHA,AJYA,AMlBA,ACHA,ARwBA,AGTA;ADIA,AIZA,AFMA,ACHA,AJYA,AMlBA,ACHA,ARwBA,AGTA;ADIA,AIZA,AFMA,ACHA,AJYA,AMlBA,ACHA,ARwBA,AGTA;ADIA,AIZA,AGTA,ALeA,ACHA,AJYA,AMlBA,ACHA,ARwBA,AGTA;ADIA,AIZA,AGTA,ALeA,ACHA,AJYA,AMlBA,ACHA,ARwBA,AGTA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,ACHA,ARwBA,AGTA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AGTA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AGTA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AGTA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AFMA,ARwBA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AOrBA,ALeA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ADIA,AENA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ACFA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ACFA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ACFA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA,ARwBA;ACFA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;APsBA,ACHA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;ANmBA,AJYA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA,AWjCA;AV+BA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,AGTA,AV8BA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;ACFA,AMlBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\r\n * ws: a node.js websocket client\r\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\nconst WebSocket = require('./lib/WebSocket');\r\n\r\nWebSocket.Server = require('./lib/WebSocketServer');\r\nWebSocket.Receiver = require('./lib/Receiver');\r\nWebSocket.Sender = require('./lib/Sender');\r\n\r\nmodule.exports = WebSocket;\r\n","/*!\r\n * ws: a node.js websocket client\r\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\nconst EventEmitter = require('events');\r\nconst crypto = require('crypto');\r\nconst Ultron = require('ultron');\r\nconst https = require('https');\r\nconst http = require('http');\r\nconst url = require('url');\r\n\r\nconst PerMessageDeflate = require('./PerMessageDeflate');\r\nconst EventTarget = require('./EventTarget');\r\nconst Extensions = require('./Extensions');\r\nconst constants = require('./Constants');\r\nconst Receiver = require('./Receiver');\r\nconst Sender = require('./Sender');\r\n\r\nconst protocolVersions = [8, 13];\r\nconst closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\r\n\r\n/**\r\n * Class representing a WebSocket.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocket extends EventEmitter {\r\n  /**\r\n   * Create a new `WebSocket`.\r\n   *\r\n   * @param {String} address The URL to which to connect\r\n   * @param {(String|String[])} protocols The subprotocols\r\n   * @param {Object} options Connection options\r\n   */\r\n  constructor (address, protocols, options) {\r\n    super();\r\n\r\n    if (!protocols) {\r\n      protocols = [];\r\n    } else if (typeof protocols === 'string') {\r\n      protocols = [protocols];\r\n    } else if (!Array.isArray(protocols)) {\r\n      options = protocols;\r\n      protocols = [];\r\n    }\r\n\r\n    this.readyState = WebSocket.CONNECTING;\r\n    this.bytesReceived = 0;\r\n    this.extensions = {};\r\n    this.protocol = '';\r\n\r\n    this._binaryType = constants.BINARY_TYPES[0];\r\n    this._finalize = this.finalize.bind(this);\r\n    this._closeFrameReceived = false;\r\n    this._closeFrameSent = false;\r\n    this._closeMessage = '';\r\n    this._closeTimer = null;\r\n    this._finalized = false;\r\n    this._closeCode = 1006;\r\n    this._receiver = null;\r\n    this._sender = null;\r\n    this._socket = null;\r\n    this._ultron = null;\r\n\r\n    if (Array.isArray(address)) {\r\n      initAsServerClient.call(this, address[0], address[1], options);\r\n    } else {\r\n      initAsClient.call(this, address, protocols, options);\r\n    }\r\n  }\r\n\r\n  get CONNECTING () { return WebSocket.CONNECTING; }\r\n  get CLOSING () { return WebSocket.CLOSING; }\r\n  get CLOSED () { return WebSocket.CLOSED; }\r\n  get OPEN () { return WebSocket.OPEN; }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get bufferedAmount () {\r\n    var amount = 0;\r\n\r\n    if (this._socket) {\r\n      amount = this._socket.bufferSize + this._sender._bufferedBytes;\r\n    }\r\n    return amount;\r\n  }\r\n\r\n  /**\r\n   * This deviates from the WHATWG interface since ws doesn't support the required\r\n   * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\r\n   *\r\n   * @type {String}\r\n   */\r\n  get binaryType () {\r\n    return this._binaryType;\r\n  }\r\n\r\n  set binaryType (type) {\r\n    if (constants.BINARY_TYPES.indexOf(type) < 0) return;\r\n\r\n    this._binaryType = type;\r\n\r\n    //\r\n    // Allow to change `binaryType` on the fly.\r\n    //\r\n    if (this._receiver) this._receiver._binaryType = type;\r\n  }\r\n\r\n  /**\r\n   * Set up the socket and the internal resources.\r\n   *\r\n   * @param {net.Socket} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @private\r\n   */\r\n  setSocket (socket, head) {\r\n    socket.setTimeout(0);\r\n    socket.setNoDelay();\r\n\r\n    this._receiver = new Receiver(this.extensions, this._maxPayload, this.binaryType);\r\n    this._sender = new Sender(socket, this.extensions);\r\n    this._ultron = new Ultron(socket);\r\n    this._socket = socket;\r\n\r\n    this._ultron.on('close', this._finalize);\r\n    this._ultron.on('error', this._finalize);\r\n    this._ultron.on('end', this._finalize);\r\n\r\n    if (head.length > 0) socket.unshift(head);\r\n\r\n    this._ultron.on('data', (data) => {\r\n      this.bytesReceived += data.length;\r\n      this._receiver.add(data);\r\n    });\r\n\r\n    this._receiver.onmessage = (data) => this.emit('message', data);\r\n    this._receiver.onping = (data) => {\r\n      this.pong(data, !this._isServer, true);\r\n      this.emit('ping', data);\r\n    };\r\n    this._receiver.onpong = (data) => this.emit('pong', data);\r\n    this._receiver.onclose = (code, reason) => {\r\n      this._closeFrameReceived = true;\r\n      this._closeMessage = reason;\r\n      this._closeCode = code;\r\n      if (!this._finalized) this.close(code, reason);\r\n    };\r\n    this._receiver.onerror = (error, code) => {\r\n      this._closeMessage = '';\r\n      this._closeCode = code;\r\n\r\n      //\r\n      // Ensure that the error is emitted even if `WebSocket#finalize()` has\r\n      // already been called.\r\n      //\r\n      this.readyState = WebSocket.CLOSING;\r\n      this.emit('error', error);\r\n      this.finalize(true);\r\n    };\r\n\r\n    this.readyState = WebSocket.OPEN;\r\n    this.emit('open');\r\n  }\r\n\r\n  /**\r\n   * Clean up and release internal resources.\r\n   *\r\n   * @param {(Boolean|Error)} error Indicates whether or not an error occurred\r\n   * @private\r\n   */\r\n  finalize (error) {\r\n    if (this._finalized) return;\r\n\r\n    this.readyState = WebSocket.CLOSING;\r\n    this._finalized = true;\r\n\r\n    if (typeof error === 'object') this.emit('error', error);\r\n    if (!this._socket) return this.emitClose();\r\n\r\n    clearTimeout(this._closeTimer);\r\n    this._closeTimer = null;\r\n\r\n    this._ultron.destroy();\r\n    this._ultron = null;\r\n\r\n    this._socket.on('error', constants.NOOP);\r\n\r\n    if (!error) this._socket.end();\r\n    else this._socket.destroy();\r\n\r\n    this._socket = null;\r\n    this._sender = null;\r\n\r\n    this._receiver.cleanup(() => this.emitClose());\r\n    this._receiver = null;\r\n  }\r\n\r\n  /**\r\n   * Emit the `close` event.\r\n   *\r\n   * @private\r\n   */\r\n  emitClose () {\r\n    this.readyState = WebSocket.CLOSED;\r\n\r\n    this.emit('close', this._closeCode, this._closeMessage);\r\n\r\n    if (this.extensions[PerMessageDeflate.extensionName]) {\r\n      this.extensions[PerMessageDeflate.extensionName].cleanup();\r\n    }\r\n\r\n    this.extensions = null;\r\n\r\n    this.removeAllListeners();\r\n  }\r\n\r\n  /**\r\n   * Pause the socket stream.\r\n   *\r\n   * @public\r\n   */\r\n  pause () {\r\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\r\n\r\n    this._socket.pause();\r\n  }\r\n\r\n  /**\r\n   * Resume the socket stream\r\n   *\r\n   * @public\r\n   */\r\n  resume () {\r\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\r\n\r\n    this._socket.resume();\r\n  }\r\n\r\n  /**\r\n   * Start a closing handshake.\r\n   *\r\n   *            +----------+     +-----------+   +----------+\r\n   *     + - - -|ws.close()|---->|close frame|-->|ws.close()|- - - -\r\n   *            +----------+     +-----------+   +----------+       |\r\n   *     |      +----------+     +-----------+         |\r\n   *            |ws.close()|<----|close frame|<--------+            |\r\n   *            +----------+     +-----------+         |\r\n   *  CLOSING         |              +---+             |         CLOSING\r\n   *                  |          +---|fin|<------------+\r\n   *     |            |          |   +---+                          |\r\n   *                  |          |   +---+      +-------------+\r\n   *     |            +----------+-->|fin|----->|ws.finalize()| - - +\r\n   *                             |   +---+      +-------------+\r\n   *     |     +-------------+   |\r\n   *      - - -|ws.finalize()|<--+\r\n   *           +-------------+\r\n   *\r\n   * @param {Number} code Status code explaining why the connection is closing\r\n   * @param {String} data A string explaining why the connection is closing\r\n   * @public\r\n   */\r\n  close (code, data) {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      this._req.abort();\r\n      this.finalize(new Error('closed before the connection is established'));\r\n      return;\r\n    }\r\n\r\n    if (this.readyState === WebSocket.CLOSING) {\r\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\r\n      return;\r\n    }\r\n\r\n    this.readyState = WebSocket.CLOSING;\r\n    this._sender.close(code, data, !this._isServer, (err) => {\r\n      //\r\n      // This error is handled by the `'error'` listener on the socket. We only\r\n      // want to know if the close frame has been sent here.\r\n      //\r\n      if (err) return;\r\n\r\n      this._closeFrameSent = true;\r\n\r\n      if (!this._finalized) {\r\n        if (this._closeFrameReceived) this._socket.end();\r\n\r\n        //\r\n        // Ensure that the connection is cleaned up even when the closing\r\n        // handshake fails.\r\n        //\r\n        this._closeTimer = setTimeout(this._finalize, closeTimeout, true);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Send a ping message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} mask Indicates whether or not to mask `data`\r\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\r\n   * @public\r\n   */\r\n  ping (data, mask, failSilently) {\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      if (failSilently) return;\r\n      throw new Error('not opened');\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.ping(data || constants.EMPTY_BUFFER, mask);\r\n  }\r\n\r\n  /**\r\n   * Send a pong message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} mask Indicates whether or not to mask `data`\r\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\r\n   * @public\r\n   */\r\n  pong (data, mask, failSilently) {\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      if (failSilently) return;\r\n      throw new Error('not opened');\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.pong(data || constants.EMPTY_BUFFER, mask);\r\n  }\r\n\r\n  /**\r\n   * Send a data message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\r\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\r\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\r\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\r\n   * @param {Function} cb Callback which is executed when data is written out\r\n   * @public\r\n   */\r\n  send (data, options, cb) {\r\n    if (typeof options === 'function') {\r\n      cb = options;\r\n      options = {};\r\n    }\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      if (cb) cb(new Error('not opened'));\r\n      else throw new Error('not opened');\r\n      return;\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    const opts = Object.assign({\r\n      binary: typeof data !== 'string',\r\n      mask: !this._isServer,\r\n      compress: true,\r\n      fin: true\r\n    }, options);\r\n\r\n    if (!this.extensions[PerMessageDeflate.extensionName]) {\r\n      opts.compress = false;\r\n    }\r\n\r\n    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\r\n  }\r\n\r\n  /**\r\n   * Forcibly close the connection.\r\n   *\r\n   * @public\r\n   */\r\n  terminate () {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      this._req.abort();\r\n      this.finalize(new Error('closed before the connection is established'));\r\n      return;\r\n    }\r\n\r\n    this.finalize(true);\r\n  }\r\n}\r\n\r\nWebSocket.CONNECTING = 0;\r\nWebSocket.OPEN = 1;\r\nWebSocket.CLOSING = 2;\r\nWebSocket.CLOSED = 3;\r\n\r\n//\r\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\r\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\r\n//\r\n['open', 'error', 'close', 'message'].forEach((method) => {\r\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\r\n    /**\r\n     * Return the listener of the event.\r\n     *\r\n     * @return {(Function|undefined)} The event listener or `undefined`\r\n     * @public\r\n     */\r\n    get () {\r\n      const listeners = this.listeners(method);\r\n      for (var i = 0; i < listeners.length; i++) {\r\n        if (listeners[i]._listener) return listeners[i]._listener;\r\n      }\r\n    },\r\n    /**\r\n     * Add a listener for the event.\r\n     *\r\n     * @param {Function} listener The listener to add\r\n     * @public\r\n     */\r\n    set (listener) {\r\n      const listeners = this.listeners(method);\r\n      for (var i = 0; i < listeners.length; i++) {\r\n        //\r\n        // Remove only the listeners added via `addEventListener`.\r\n        //\r\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\r\n      }\r\n      this.addEventListener(method, listener);\r\n    }\r\n  });\r\n});\r\n\r\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\r\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\r\n\r\nmodule.exports = WebSocket;\r\n\r\n/**\r\n * Initialize a WebSocket server client.\r\n *\r\n * @param {http.IncomingMessage} req The request object\r\n * @param {net.Socket} socket The network socket between the server and client\r\n * @param {Buffer} head The first packet of the upgraded stream\r\n * @param {Object} options WebSocket attributes\r\n * @param {Number} options.protocolVersion The WebSocket protocol version\r\n * @param {Object} options.extensions The negotiated extensions\r\n * @param {Number} options.maxPayload The maximum allowed message size\r\n * @param {String} options.protocol The chosen subprotocol\r\n * @private\r\n */\r\nfunction initAsServerClient (socket, head, options) {\r\n  this.protocolVersion = options.protocolVersion;\r\n  this._maxPayload = options.maxPayload;\r\n  this.extensions = options.extensions;\r\n  this.protocol = options.protocol;\r\n\r\n  this._isServer = true;\r\n\r\n  this.setSocket(socket, head);\r\n}\r\n\r\n/**\r\n * Initialize a WebSocket client.\r\n *\r\n * @param {String} address The URL to which to connect\r\n * @param {String[]} protocols The list of subprotocols\r\n * @param {Object} options Connection options\r\n * @param {String} options.protocol Value of the `Sec-WebSocket-Protocol` header\r\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\r\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\r\n * @param {String} options.localAddress Local interface to bind for network connections\r\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\r\n * @param {Object} options.headers An object containing request headers\r\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\r\n * @param {http.Agent} options.agent Use the specified Agent\r\n * @param {String} options.host Value of the `Host` header\r\n * @param {Number} options.family IP address family to use during hostname lookup (4 or 6).\r\n * @param {Function} options.checkServerIdentity A function to validate the server hostname\r\n * @param {Boolean} options.rejectUnauthorized Verify or not the server certificate\r\n * @param {String} options.passphrase The passphrase for the private key or pfx\r\n * @param {String} options.ciphers The ciphers to use or exclude\r\n * @param {String} options.ecdhCurve The curves for ECDH key agreement to use or exclude\r\n * @param {(String|String[]|Buffer|Buffer[])} options.cert The certificate key\r\n * @param {(String|String[]|Buffer|Buffer[])} options.key The private key\r\n * @param {(String|Buffer)} options.pfx The private key, certificate, and CA certs\r\n * @param {(String|String[]|Buffer|Buffer[])} options.ca Trusted certificates\r\n * @private\r\n */\r\nfunction initAsClient (address, protocols, options) {\r\n  options = Object.assign({\r\n    protocolVersion: protocolVersions[1],\r\n    protocol: protocols.join(','),\r\n    perMessageDeflate: true,\r\n    handshakeTimeout: null,\r\n    localAddress: null,\r\n    headers: null,\r\n    family: null,\r\n    origin: null,\r\n    agent: null,\r\n    host: null,\r\n\r\n    //\r\n    // SSL options.\r\n    //\r\n    checkServerIdentity: null,\r\n    rejectUnauthorized: null,\r\n    passphrase: null,\r\n    ciphers: null,\r\n    ecdhCurve: null,\r\n    cert: null,\r\n    key: null,\r\n    pfx: null,\r\n    ca: null\r\n  }, options);\r\n\r\n  if (protocolVersions.indexOf(options.protocolVersion) === -1) {\r\n    throw new Error(\r\n      `unsupported protocol version: ${options.protocolVersion} ` +\r\n      `(supported versions: ${protocolVersions.join(', ')})`\r\n    );\r\n  }\r\n\r\n  this.protocolVersion = options.protocolVersion;\r\n  this._isServer = false;\r\n  this.url = address;\r\n\r\n  const serverUrl = url.parse(address);\r\n  const isUnixSocket = serverUrl.protocol === 'ws+unix:';\r\n\r\n  if (!serverUrl.host && (!isUnixSocket || !serverUrl.path)) {\r\n    throw new Error('invalid url');\r\n  }\r\n\r\n  const isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\r\n  const key = crypto.randomBytes(16).toString('base64');\r\n  const httpObj = isSecure ? https : http;\r\n  var perMessageDeflate;\r\n\r\n  const requestOptions = {\r\n    port: serverUrl.port || (isSecure ? 443 : 80),\r\n    host: serverUrl.hostname,\r\n    path: '/',\r\n    headers: {\r\n      'Sec-WebSocket-Version': options.protocolVersion,\r\n      'Sec-WebSocket-Key': key,\r\n      'Connection': 'Upgrade',\r\n      'Upgrade': 'websocket'\r\n    }\r\n  };\r\n\r\n  if (options.headers) Object.assign(requestOptions.headers, options.headers);\r\n  if (options.perMessageDeflate) {\r\n    perMessageDeflate = new PerMessageDeflate(\r\n      options.perMessageDeflate !== true ? options.perMessageDeflate : {},\r\n      false\r\n    );\r\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format({\r\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\r\n    });\r\n  }\r\n  if (options.protocol) {\r\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.protocol;\r\n  }\r\n  if (options.origin) {\r\n    if (options.protocolVersion < 13) {\r\n      requestOptions.headers['Sec-WebSocket-Origin'] = options.origin;\r\n    } else {\r\n      requestOptions.headers.Origin = options.origin;\r\n    }\r\n  }\r\n  if (options.host) requestOptions.headers.Host = options.host;\r\n  if (serverUrl.auth) requestOptions.auth = serverUrl.auth;\r\n\r\n  if (options.localAddress) requestOptions.localAddress = options.localAddress;\r\n  if (options.family) requestOptions.family = options.family;\r\n\r\n  if (isUnixSocket) {\r\n    const parts = serverUrl.path.split(':');\r\n\r\n    requestOptions.socketPath = parts[0];\r\n    requestOptions.path = parts[1];\r\n  } else if (serverUrl.path) {\r\n    //\r\n    // Make sure that path starts with `/`.\r\n    //\r\n    if (serverUrl.path.charAt(0) !== '/') {\r\n      requestOptions.path = `/${serverUrl.path}`;\r\n    } else {\r\n      requestOptions.path = serverUrl.path;\r\n    }\r\n  }\r\n\r\n  var agent = options.agent;\r\n\r\n  //\r\n  // A custom agent is required for these options.\r\n  //\r\n  if (\r\n    options.rejectUnauthorized != null ||\r\n    options.checkServerIdentity ||\r\n    options.passphrase ||\r\n    options.ciphers ||\r\n    options.ecdhCurve ||\r\n    options.cert ||\r\n    options.key ||\r\n    options.pfx ||\r\n    options.ca\r\n  ) {\r\n    if (options.passphrase) requestOptions.passphrase = options.passphrase;\r\n    if (options.ciphers) requestOptions.ciphers = options.ciphers;\r\n    if (options.ecdhCurve) requestOptions.ecdhCurve = options.ecdhCurve;\r\n    if (options.cert) requestOptions.cert = options.cert;\r\n    if (options.key) requestOptions.key = options.key;\r\n    if (options.pfx) requestOptions.pfx = options.pfx;\r\n    if (options.ca) requestOptions.ca = options.ca;\r\n    if (options.checkServerIdentity) {\r\n      requestOptions.checkServerIdentity = options.checkServerIdentity;\r\n    }\r\n    if (options.rejectUnauthorized != null) {\r\n      requestOptions.rejectUnauthorized = options.rejectUnauthorized;\r\n    }\r\n\r\n    if (!agent) agent = new httpObj.Agent(requestOptions);\r\n  }\r\n\r\n  if (agent) requestOptions.agent = agent;\r\n\r\n  this._req = httpObj.get(requestOptions);\r\n\r\n  if (options.handshakeTimeout) {\r\n    this._req.setTimeout(options.handshakeTimeout, () => {\r\n      this._req.abort();\r\n      this.finalize(new Error('opening handshake has timed out'));\r\n    });\r\n  }\r\n\r\n  this._req.on('error', (error) => {\r\n    if (this._req.aborted) return;\r\n\r\n    this._req = null;\r\n    this.finalize(error);\r\n  });\r\n\r\n  this._req.on('response', (res) => {\r\n    if (!this.emit('unexpected-response', this._req, res)) {\r\n      this._req.abort();\r\n      this.finalize(new Error(`unexpected server response (${res.statusCode})`));\r\n    }\r\n  });\r\n\r\n  this._req.on('upgrade', (res, socket, head) => {\r\n    this.emit('headers', res.headers, res);\r\n\r\n    //\r\n    // The user may have closed the connection from a listener of the `headers`\r\n    // event.\r\n    //\r\n    if (this.readyState !== WebSocket.CONNECTING) return;\r\n\r\n    this._req = null;\r\n\r\n    const digest = crypto.createHash('sha1')\r\n      .update(key + constants.GUID, 'binary')\r\n      .digest('base64');\r\n\r\n    if (res.headers['sec-websocket-accept'] !== digest) {\r\n      socket.destroy();\r\n      return this.finalize(new Error('invalid server key'));\r\n    }\r\n\r\n    const serverProt = res.headers['sec-websocket-protocol'];\r\n    const protList = (options.protocol || '').split(/, */);\r\n    var protError;\r\n\r\n    if (!options.protocol && serverProt) {\r\n      protError = 'server sent a subprotocol even though none requested';\r\n    } else if (options.protocol && !serverProt) {\r\n      protError = 'server sent no subprotocol even though requested';\r\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\r\n      protError = 'server responded with an invalid protocol';\r\n    }\r\n\r\n    if (protError) {\r\n      socket.destroy();\r\n      return this.finalize(new Error(protError));\r\n    }\r\n\r\n    if (serverProt) this.protocol = serverProt;\r\n\r\n    if (perMessageDeflate) {\r\n      try {\r\n        const serverExtensions = Extensions.parse(\r\n          res.headers['sec-websocket-extensions']\r\n        );\r\n\r\n        if (serverExtensions[PerMessageDeflate.extensionName]) {\r\n          perMessageDeflate.accept(\r\n            serverExtensions[PerMessageDeflate.extensionName]\r\n          );\r\n          this.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\r\n        }\r\n      } catch (err) {\r\n        socket.destroy();\r\n        this.finalize(new Error('invalid Sec-WebSocket-Extensions header'));\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.setSocket(socket, head);\r\n  });\r\n}\r\n","\r\n\r\nconst safeBuffer = require('safe-buffer');\r\nconst Limiter = require('async-limiter');\r\nconst zlib = require('zlib');\r\n\r\nconst bufferUtil = require('./BufferUtil');\r\n\r\nconst Buffer = safeBuffer.Buffer;\r\n\r\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\r\nconst EMPTY_BLOCK = Buffer.from([0x00]);\r\n\r\nconst kWriteInProgress = Symbol('write-in-progress');\r\nconst kPendingClose = Symbol('pending-close');\r\nconst kTotalLength = Symbol('total-length');\r\nconst kCallback = Symbol('callback');\r\nconst kBuffers = Symbol('buffers');\r\nconst kError = Symbol('error');\r\nconst kOwner = Symbol('owner');\r\n\r\n//\r\n// We limit zlib concurrency, which prevents severe memory fragmentation\r\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\r\n// and https://github.com/websockets/ws/issues/1202\r\n//\r\n// Intentionally global; it's the global thread pool that's an issue.\r\n//\r\nlet zlibLimiter;\r\n\r\n/**\r\n * permessage-deflate implementation.\r\n */\r\nclass PerMessageDeflate {\r\n  /**\r\n   * Creates a PerMessageDeflate instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\r\n   *     of server context takeover\r\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\r\n   *     disabling of client context takeover\r\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\r\n   *     use of a custom server window size\r\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\r\n   *     for, or request, a custom client window size\r\n   * @param {Number} options.level The value of zlib's `level` param\r\n   * @param {Number} options.memLevel The value of zlib's `memLevel` param\r\n   * @param {Number} options.threshold Size (in bytes) below which messages\r\n   *     should not be compressed\r\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\r\n   *     zlib\r\n   * @param {Boolean} isServer Create the instance in either server or client\r\n   *     mode\r\n   * @param {Number} maxPayload The maximum allowed message length\r\n   */\r\n  constructor (options, isServer, maxPayload) {\r\n    this._maxPayload = maxPayload | 0;\r\n    this._options = options || {};\r\n    this._threshold = this._options.threshold !== undefined\r\n      ? this._options.threshold\r\n      : 1024;\r\n    this._isServer = !!isServer;\r\n    this._deflate = null;\r\n    this._inflate = null;\r\n\r\n    this.params = null;\r\n\r\n    if (!zlibLimiter) {\r\n      const concurrency = this._options.concurrencyLimit !== undefined\r\n        ? this._options.concurrencyLimit\r\n        : 10;\r\n      zlibLimiter = new Limiter({ concurrency });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  static get extensionName () {\r\n    return 'permessage-deflate';\r\n  }\r\n\r\n  /**\r\n   * Create extension parameters offer.\r\n   *\r\n   * @return {Object} Extension parameters\r\n   * @public\r\n   */\r\n  offer () {\r\n    const params = {};\r\n\r\n    if (this._options.serverNoContextTakeover) {\r\n      params.server_no_context_takeover = true;\r\n    }\r\n    if (this._options.clientNoContextTakeover) {\r\n      params.client_no_context_takeover = true;\r\n    }\r\n    if (this._options.serverMaxWindowBits) {\r\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\r\n    }\r\n    if (this._options.clientMaxWindowBits) {\r\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n    } else if (this._options.clientMaxWindowBits == null) {\r\n      params.client_max_window_bits = true;\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Accept extension offer.\r\n   *\r\n   * @param {Array} paramsList Extension parameters\r\n   * @return {Object} Accepted configuration\r\n   * @public\r\n   */\r\n  accept (paramsList) {\r\n    paramsList = this.normalizeParams(paramsList);\r\n\r\n    var params;\r\n    if (this._isServer) {\r\n      params = this.acceptAsServer(paramsList);\r\n    } else {\r\n      params = this.acceptAsClient(paramsList);\r\n    }\r\n\r\n    this.params = params;\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Releases all resources used by the extension.\r\n   *\r\n   * @public\r\n   */\r\n  cleanup () {\r\n    if (this._inflate) {\r\n      if (this._inflate[kWriteInProgress]) {\r\n        this._inflate[kPendingClose] = true;\r\n      } else {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n      }\r\n    }\r\n    if (this._deflate) {\r\n      if (this._deflate[kWriteInProgress]) {\r\n        this._deflate[kPendingClose] = true;\r\n      } else {\r\n        this._deflate.close();\r\n        this._deflate = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Accept extension offer from client.\r\n   *\r\n   * @param {Array} paramsList Extension parameters\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsServer (paramsList) {\r\n    const accepted = {};\r\n    const result = paramsList.some((params) => {\r\n      if (\r\n        (this._options.serverNoContextTakeover === false &&\r\n          params.server_no_context_takeover) ||\r\n        (this._options.serverMaxWindowBits === false &&\r\n          params.server_max_window_bits) ||\r\n        (typeof this._options.serverMaxWindowBits === 'number' &&\r\n          typeof params.server_max_window_bits === 'number' &&\r\n          this._options.serverMaxWindowBits > params.server_max_window_bits) ||\r\n        (typeof this._options.clientMaxWindowBits === 'number' &&\r\n          !params.client_max_window_bits)\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        this._options.serverNoContextTakeover ||\r\n        params.server_no_context_takeover\r\n      ) {\r\n        accepted.server_no_context_takeover = true;\r\n      }\r\n      if (\r\n        this._options.clientNoContextTakeover ||\r\n        (this._options.clientNoContextTakeover !== false &&\r\n          params.client_no_context_takeover)\r\n      ) {\r\n        accepted.client_no_context_takeover = true;\r\n      }\r\n      if (typeof this._options.serverMaxWindowBits === 'number') {\r\n        accepted.server_max_window_bits = this._options.serverMaxWindowBits;\r\n      } else if (typeof params.server_max_window_bits === 'number') {\r\n        accepted.server_max_window_bits = params.server_max_window_bits;\r\n      }\r\n      if (typeof this._options.clientMaxWindowBits === 'number') {\r\n        accepted.client_max_window_bits = this._options.clientMaxWindowBits;\r\n      } else if (\r\n        this._options.clientMaxWindowBits !== false &&\r\n        typeof params.client_max_window_bits === 'number'\r\n      ) {\r\n        accepted.client_max_window_bits = params.client_max_window_bits;\r\n      }\r\n      return true;\r\n    });\r\n\r\n    if (!result) throw new Error(\"Doesn't support the offered configuration\");\r\n\r\n    return accepted;\r\n  }\r\n\r\n  /**\r\n   * Accept extension response from server.\r\n   *\r\n   * @param {Array} paramsList Extension parameters\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsClient (paramsList) {\r\n    const params = paramsList[0];\r\n\r\n    if (\r\n      this._options.clientNoContextTakeover === false &&\r\n      params.client_no_context_takeover\r\n    ) {\r\n      throw new Error('Invalid value for \"client_no_context_takeover\"');\r\n    }\r\n\r\n    if (\r\n      (typeof this._options.clientMaxWindowBits === 'number' &&\r\n        (!params.client_max_window_bits ||\r\n          params.client_max_window_bits > this._options.clientMaxWindowBits)) ||\r\n      (this._options.clientMaxWindowBits === false &&\r\n        params.client_max_window_bits)\r\n    ) {\r\n      throw new Error('Invalid value for \"client_max_window_bits\"');\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Normalize extensions parameters.\r\n   *\r\n   * @param {Array} paramsList Extension parameters\r\n   * @return {Array} Normalized extensions parameters\r\n   * @private\r\n   */\r\n  normalizeParams (paramsList) {\r\n    return paramsList.map((params) => {\r\n      Object.keys(params).forEach((key) => {\r\n        var value = params[key];\r\n        if (value.length > 1) {\r\n          throw new Error(`Multiple extension parameters for ${key}`);\r\n        }\r\n\r\n        value = value[0];\r\n\r\n        switch (key) {\r\n          case 'server_no_context_takeover':\r\n          case 'client_no_context_takeover':\r\n            if (value !== true) {\r\n              throw new Error(`invalid extension parameter value for ${key} (${value})`);\r\n            }\r\n            params[key] = true;\r\n            break;\r\n          case 'server_max_window_bits':\r\n          case 'client_max_window_bits':\r\n            if (typeof value === 'string') {\r\n              value = parseInt(value, 10);\r\n              if (\r\n                Number.isNaN(value) ||\r\n                value < zlib.Z_MIN_WINDOWBITS ||\r\n                value > zlib.Z_MAX_WINDOWBITS\r\n              ) {\r\n                throw new Error(`invalid extension parameter value for ${key} (${value})`);\r\n              }\r\n            }\r\n            if (!this._isServer && value === true) {\r\n              throw new Error(`Missing extension parameter value for ${key}`);\r\n            }\r\n            params[key] = value;\r\n            break;\r\n          default:\r\n            throw new Error(`Not defined extension parameter (${key})`);\r\n        }\r\n      });\r\n      return params;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Decompress data. Concurrency limited by async-limiter.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  decompress (data, fin, callback) {\r\n    zlibLimiter.push((done) => {\r\n      this._decompress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data. Concurrency limited by async-limiter.\r\n   *\r\n   * @param {Buffer} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  compress (data, fin, callback) {\r\n    zlibLimiter.push((done) => {\r\n      this._compress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Decompress data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _decompress (data, fin, callback) {\r\n    const endpoint = this._isServer ? 'client' : 'server';\r\n\r\n    if (!this._inflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits = typeof this.params[key] !== 'number'\r\n        ? zlib.Z_DEFAULT_WINDOWBITS\r\n        : this.params[key];\r\n\r\n      this._inflate = zlib.createInflateRaw({ windowBits });\r\n      this._inflate[kTotalLength] = 0;\r\n      this._inflate[kBuffers] = [];\r\n      this._inflate[kOwner] = this;\r\n      this._inflate.on('error', inflateOnError);\r\n      this._inflate.on('data', inflateOnData);\r\n    }\r\n\r\n    this._inflate[kCallback] = callback;\r\n    this._inflate[kWriteInProgress] = true;\r\n\r\n    this._inflate.write(data);\r\n    if (fin) this._inflate.write(TRAILER);\r\n\r\n    this._inflate.flush(() => {\r\n      const err = this._inflate[kError];\r\n\r\n      if (err) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      const data = bufferUtil.concat(\r\n        this._inflate[kBuffers],\r\n        this._inflate[kTotalLength]\r\n      );\r\n\r\n      if (\r\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\r\n        this._inflate[kPendingClose]\r\n      ) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n      } else {\r\n        this._inflate[kWriteInProgress] = false;\r\n        this._inflate[kTotalLength] = 0;\r\n        this._inflate[kBuffers] = [];\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data.\r\n   *\r\n   * @param {Buffer} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _compress (data, fin, callback) {\r\n    if (!data || data.length === 0) {\r\n      process.nextTick(callback, null, EMPTY_BLOCK);\r\n      return;\r\n    }\r\n\r\n    const endpoint = this._isServer ? 'server' : 'client';\r\n\r\n    if (!this._deflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits = typeof this.params[key] !== 'number'\r\n        ? zlib.Z_DEFAULT_WINDOWBITS\r\n        : this.params[key];\r\n\r\n      this._deflate = zlib.createDeflateRaw({\r\n        memLevel: this._options.memLevel,\r\n        level: this._options.level,\r\n        flush: zlib.Z_SYNC_FLUSH,\r\n        windowBits\r\n      });\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      //\r\n      // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\r\n      // it is made after it has already been closed. This cannot happen here,\r\n      // so we only add a listener for the `'data'` event.\r\n      //\r\n      this._deflate.on('data', deflateOnData);\r\n    }\r\n\r\n    this._deflate[kWriteInProgress] = true;\r\n\r\n    this._deflate.write(data);\r\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\r\n      var data = bufferUtil.concat(\r\n        this._deflate[kBuffers],\r\n        this._deflate[kTotalLength]\r\n      );\r\n\r\n      if (fin) data = data.slice(0, data.length - 4);\r\n\r\n      if (\r\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\r\n        this._deflate[kPendingClose]\r\n      ) {\r\n        this._deflate.close();\r\n        this._deflate = null;\r\n      } else {\r\n        this._deflate[kWriteInProgress] = false;\r\n        this._deflate[kTotalLength] = 0;\r\n        this._deflate[kBuffers] = [];\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = PerMessageDeflate;\r\n\r\n/**\r\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction deflateOnData (chunk) {\r\n  this[kBuffers].push(chunk);\r\n  this[kTotalLength] += chunk.length;\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction inflateOnData (chunk) {\r\n  this[kTotalLength] += chunk.length;\r\n\r\n  if (\r\n    this[kOwner]._maxPayload < 1 ||\r\n    this[kTotalLength] <= this[kOwner]._maxPayload\r\n  ) {\r\n    this[kBuffers].push(chunk);\r\n    return;\r\n  }\r\n\r\n  this[kError] = new Error('max payload size exceeded');\r\n  this[kError].closeCode = 1009;\r\n  this.removeListener('data', inflateOnData);\r\n  this.reset();\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\r\n *\r\n * @param {Error} err The emitted error\r\n * @private\r\n */\r\nfunction inflateOnError (err) {\r\n  //\r\n  // There is no need to call `Zlib#close()` as the handle is automatically\r\n  // closed when an error is emitted.\r\n  //\r\n  this[kOwner]._inflate = null;\r\n  this[kCallback](err);\r\n}\r\n","/*!\r\n * ws: a node.js websocket client\r\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\nconst safeBuffer = require('safe-buffer');\r\n\r\nconst Buffer = safeBuffer.Buffer;\r\n\r\n/**\r\n * Merges an array of buffers into a new buffer.\r\n *\r\n * @param {Buffer[]} list The array of buffers to concat\r\n * @param {Number} totalLength The total length of buffers in the list\r\n * @return {Buffer} The resulting buffer\r\n * @public\r\n */\r\nconst concat = (list, totalLength) => {\r\n  const target = Buffer.allocUnsafe(totalLength);\r\n  var offset = 0;\r\n\r\n  for (var i = 0; i < list.length; i++) {\r\n    const buf = list[i];\r\n    buf.copy(target, offset);\r\n    offset += buf.length;\r\n  }\r\n\r\n  return target;\r\n};\r\n\r\ntry {\r\n  const bufferUtil = require('bufferutil');\r\n\r\n  module.exports = Object.assign({ concat }, bufferUtil.BufferUtil || bufferUtil);\r\n} catch (e) /* istanbul ignore next */ {\r\n  /**\r\n   * Masks a buffer using the given mask.\r\n   *\r\n   * @param {Buffer} source The buffer to mask\r\n   * @param {Buffer} mask The mask to use\r\n   * @param {Buffer} output The buffer where to store the result\r\n   * @param {Number} offset The offset at which to start writing\r\n   * @param {Number} length The number of bytes to mask.\r\n   * @public\r\n   */\r\n  const mask = (source, mask, output, offset, length) => {\r\n    for (var i = 0; i < length; i++) {\r\n      output[offset + i] = source[i] ^ mask[i & 3];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Unmasks a buffer using the given mask.\r\n   *\r\n   * @param {Buffer} buffer The buffer to unmask\r\n   * @param {Buffer} mask The mask to use\r\n   * @public\r\n   */\r\n  const unmask = (buffer, mask) => {\r\n    // Required until https://github.com/nodejs/node/issues/9006 is resolved.\r\n    const length = buffer.length;\r\n    for (var i = 0; i < length; i++) {\r\n      buffer[i] ^= mask[i & 3];\r\n    }\r\n  };\r\n\r\n  module.exports = { concat, mask, unmask };\r\n}\r\n","/*!\r\n * ws: a node.js websocket client\r\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\nconst safeBuffer = require('safe-buffer');\r\n\r\nconst Buffer = safeBuffer.Buffer;\r\n\r\n/**\r\n * Merges an array of buffers into a new buffer.\r\n *\r\n * @param {Buffer[]} list The array of buffers to concat\r\n * @param {Number} totalLength The total length of buffers in the list\r\n * @return {Buffer} The resulting buffer\r\n * @public\r\n */\r\nconst concat = (list, totalLength) => {\r\n  const target = Buffer.allocUnsafe(totalLength);\r\n  var offset = 0;\r\n\r\n  for (var i = 0; i < list.length; i++) {\r\n    const buf = list[i];\r\n    buf.copy(target, offset);\r\n    offset += buf.length;\r\n  }\r\n\r\n  return target;\r\n};\r\n\r\ntry {\r\n  const bufferUtil = require('bufferutil');\r\n\r\n  module.exports = Object.assign({ concat }, bufferUtil.BufferUtil || bufferUtil);\r\n} catch (e) /* istanbul ignore next */ {\r\n  /**\r\n   * Masks a buffer using the given mask.\r\n   *\r\n   * @param {Buffer} source The buffer to mask\r\n   * @param {Buffer} mask The mask to use\r\n   * @param {Buffer} output The buffer where to store the result\r\n   * @param {Number} offset The offset at which to start writing\r\n   * @param {Number} length The number of bytes to mask.\r\n   * @public\r\n   */\r\n  const mask = (source, mask, output, offset, length) => {\r\n    for (var i = 0; i < length; i++) {\r\n      output[offset + i] = source[i] ^ mask[i & 3];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Unmasks a buffer using the given mask.\r\n   *\r\n   * @param {Buffer} buffer The buffer to unmask\r\n   * @param {Buffer} mask The mask to use\r\n   * @public\r\n   */\r\n  const unmask = (buffer, mask) => {\r\n    // Required until https://github.com/nodejs/node/issues/9006 is resolved.\r\n    const length = buffer.length;\r\n    for (var i = 0; i < length; i++) {\r\n      buffer[i] ^= mask[i & 3];\r\n    }\r\n  };\r\n\r\n  module.exports = { concat, mask, unmask };\r\n}\r\n","\r\n\r\n/**\r\n * Class representing an event.\r\n *\r\n * @private\r\n */\r\nclass Event {\r\n  /**\r\n   * Create a new `Event`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} target A reference to the target to which the event was dispatched\r\n   */\r\n  constructor (type, target) {\r\n    this.target = target;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\n/**\r\n * Class representing a message event.\r\n *\r\n * @extends Event\r\n * @private\r\n */\r\nclass MessageEvent extends Event {\r\n  /**\r\n   * Create a new `MessageEvent`.\r\n   *\r\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\r\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\r\n   */\r\n  constructor (data, target) {\r\n    super('message', target);\r\n\r\n    this.data = data;\r\n  }\r\n}\r\n\r\n/**\r\n * Class representing a close event.\r\n *\r\n * @extends Event\r\n * @private\r\n */\r\nclass CloseEvent extends Event {\r\n  /**\r\n   * Create a new `CloseEvent`.\r\n   *\r\n   * @param {Number} code The status code explaining why the connection is being closed\r\n   * @param {String} reason A human-readable string explaining why the connection is closing\r\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\r\n   */\r\n  constructor (code, reason, target) {\r\n    super('close', target);\r\n\r\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\r\n    this.reason = reason;\r\n    this.code = code;\r\n  }\r\n}\r\n\r\n/**\r\n * Class representing an open event.\r\n *\r\n * @extends Event\r\n * @private\r\n */\r\nclass OpenEvent extends Event {\r\n  /**\r\n   * Create a new `OpenEvent`.\r\n   *\r\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\r\n   */\r\n  constructor (target) {\r\n    super('open', target);\r\n  }\r\n}\r\n\r\n/**\r\n * This provides methods for emulating the `EventTarget` interface. It's not\r\n * meant to be used directly.\r\n *\r\n * @mixin\r\n */\r\nconst EventTarget = {\r\n  /**\r\n   * Register an event listener.\r\n   *\r\n   * @param {String} method A string representing the event type to listen for\r\n   * @param {Function} listener The listener to add\r\n   * @public\r\n   */\r\n  addEventListener (method, listener) {\r\n    if (typeof listener !== 'function') return;\r\n\r\n    function onMessage (data) {\r\n      listener.call(this, new MessageEvent(data, this));\r\n    }\r\n\r\n    function onClose (code, message) {\r\n      listener.call(this, new CloseEvent(code, message, this));\r\n    }\r\n\r\n    function onError (event) {\r\n      event.type = 'error';\r\n      event.target = this;\r\n      listener.call(this, event);\r\n    }\r\n\r\n    function onOpen () {\r\n      listener.call(this, new OpenEvent(this));\r\n    }\r\n\r\n    if (method === 'message') {\r\n      onMessage._listener = listener;\r\n      this.on(method, onMessage);\r\n    } else if (method === 'close') {\r\n      onClose._listener = listener;\r\n      this.on(method, onClose);\r\n    } else if (method === 'error') {\r\n      onError._listener = listener;\r\n      this.on(method, onError);\r\n    } else if (method === 'open') {\r\n      onOpen._listener = listener;\r\n      this.on(method, onOpen);\r\n    } else {\r\n      this.on(method, listener);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Remove an event listener.\r\n   *\r\n   * @param {String} method A string representing the event type to remove\r\n   * @param {Function} listener The listener to remove\r\n   * @public\r\n   */\r\n  removeEventListener (method, listener) {\r\n    const listeners = this.listeners(method);\r\n\r\n    for (var i = 0; i < listeners.length; i++) {\r\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\r\n        this.removeListener(method, listeners[i]);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = EventTarget;\r\n","\r\n\r\n//\r\n// Allowed token characters:\r\n//\r\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\r\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\r\n//\r\n// tokenChars[32] === 0 // ' '\r\n// tokenChars[33] === 1 // '!'\r\n// tokenChars[34] === 0 // '\"'\r\n// ...\r\n//\r\nconst tokenChars = [\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\r\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\r\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\r\n];\r\n\r\n/**\r\n * Adds an offer to the map of extension offers or a parameter to the map of\r\n * parameters.\r\n *\r\n * @param {Object} dest The map of extension offers or parameters\r\n * @param {String} name The extension or parameter name\r\n * @param {(Object|Boolean|String)} elem The extension parameters or the\r\n *     parameter value\r\n * @private\r\n */\r\nfunction push (dest, name, elem) {\r\n  if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);\r\n  else dest[name] = [elem];\r\n}\r\n\r\n/**\r\n * Parses the `Sec-WebSocket-Extensions` header into an object.\r\n *\r\n * @param {String} header The field value of the header\r\n * @return {Object} The parsed object\r\n * @public\r\n */\r\nfunction parse (header) {\r\n  const offers = {};\r\n\r\n  if (header === undefined || header === '') return offers;\r\n\r\n  var params = {};\r\n  var mustUnescape = false;\r\n  var isEscaping = false;\r\n  var inQuotes = false;\r\n  var extensionName;\r\n  var paramName;\r\n  var start = -1;\r\n  var end = -1;\r\n\r\n  for (var i = 0; i < header.length; i++) {\r\n    const code = header.charCodeAt(i);\r\n\r\n    if (extensionName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (code === 0x20/* ' ' */|| code === 0x09/* '\\t' */) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b/* ';' */ || code === 0x2c/* ',' */) {\r\n        if (start === -1) throw new Error(`unexpected character at index ${i}`);\r\n\r\n        if (end === -1) end = i;\r\n        const name = header.slice(start, end);\r\n        if (code === 0x2c) {\r\n          push(offers, name, params);\r\n          params = {};\r\n        } else {\r\n          extensionName = name;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else {\r\n        throw new Error(`unexpected character at index ${i}`);\r\n      }\r\n    } else if (paramName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (code === 0x20 || code === 0x09) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) throw new Error(`unexpected character at index ${i}`);\r\n\r\n        if (end === -1) end = i;\r\n        push(params, header.slice(start, end), true);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = {};\r\n          extensionName = undefined;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else if (code === 0x3d/* '=' */&& start !== -1 && end === -1) {\r\n        paramName = header.slice(start, i);\r\n        start = end = -1;\r\n      } else {\r\n        throw new Error(`unexpected character at index ${i}`);\r\n      }\r\n    } else {\r\n      //\r\n      // The value of a quoted-string after unescaping must conform to the\r\n      // token ABNF, so only token characters are valid.\r\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\r\n      //\r\n      if (isEscaping) {\r\n        if (tokenChars[code] !== 1) {\r\n          throw new Error(`unexpected character at index ${i}`);\r\n        }\r\n        if (start === -1) start = i;\r\n        else if (!mustUnescape) mustUnescape = true;\r\n        isEscaping = false;\r\n      } else if (inQuotes) {\r\n        if (tokenChars[code] === 1) {\r\n          if (start === -1) start = i;\r\n        } else if (code === 0x22/* '\"' */ && start !== -1) {\r\n          inQuotes = false;\r\n          end = i;\r\n        } else if (code === 0x5c/* '\\' */) {\r\n          isEscaping = true;\r\n        } else {\r\n          throw new Error(`unexpected character at index ${i}`);\r\n        }\r\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\r\n        inQuotes = true;\r\n      } else if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\r\n        if (end === -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) throw new Error(`unexpected character at index ${i}`);\r\n\r\n        if (end === -1) end = i;\r\n        var value = header.slice(start, end);\r\n        if (mustUnescape) {\r\n          value = value.replace(/\\\\/g, '');\r\n          mustUnescape = false;\r\n        }\r\n        push(params, paramName, value);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = {};\r\n          extensionName = undefined;\r\n        }\r\n\r\n        paramName = undefined;\r\n        start = end = -1;\r\n      } else {\r\n        throw new Error(`unexpected character at index ${i}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (start === -1 || inQuotes) throw new Error('unexpected end of input');\r\n\r\n  if (end === -1) end = i;\r\n  const token = header.slice(start, end);\r\n  if (extensionName === undefined) {\r\n    push(offers, token, {});\r\n  } else {\r\n    if (paramName === undefined) {\r\n      push(params, token, true);\r\n    } else if (mustUnescape) {\r\n      push(params, paramName, token.replace(/\\\\/g, ''));\r\n    } else {\r\n      push(params, paramName, token);\r\n    }\r\n    push(offers, extensionName, params);\r\n  }\r\n\r\n  return offers;\r\n}\r\n\r\n/**\r\n * Serializes a parsed `Sec-WebSocket-Extensions` header to a string.\r\n *\r\n * @param {Object} value The object to format\r\n * @return {String} A string representing the given value\r\n * @public\r\n */\r\nfunction format (value) {\r\n  return Object.keys(value).map((token) => {\r\n    var paramsList = value[token];\r\n    if (!Array.isArray(paramsList)) paramsList = [paramsList];\r\n    return paramsList.map((params) => {\r\n      return [token].concat(Object.keys(params).map((k) => {\r\n        var p = params[k];\r\n        if (!Array.isArray(p)) p = [p];\r\n        return p.map((v) => v === true ? k : `${k}=${v}`).join('; ');\r\n      })).join('; ');\r\n    }).join(', ');\r\n  }).join(', ');\r\n}\r\n\r\nmodule.exports = { format, parse };\r\n","\r\n\r\nconst safeBuffer = require('safe-buffer');\r\n\r\nconst Buffer = safeBuffer.Buffer;\r\n\r\nexports.BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\r\nexports.GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\r\nexports.EMPTY_BUFFER = Buffer.alloc(0);\r\nexports.NOOP = () => {};\r\n","/*!\r\n * ws: a node.js websocket client\r\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\nconst safeBuffer = require('safe-buffer');\r\n\r\nconst PerMessageDeflate = require('./PerMessageDeflate');\r\nconst isValidUTF8 = require('./Validation');\r\nconst bufferUtil = require('./BufferUtil');\r\nconst ErrorCodes = require('./ErrorCodes');\r\nconst constants = require('./Constants');\r\n\r\nconst Buffer = safeBuffer.Buffer;\r\n\r\nconst GET_INFO = 0;\r\nconst GET_PAYLOAD_LENGTH_16 = 1;\r\nconst GET_PAYLOAD_LENGTH_64 = 2;\r\nconst GET_MASK = 3;\r\nconst GET_DATA = 4;\r\nconst INFLATING = 5;\r\n\r\n/**\r\n * HyBi Receiver implementation.\r\n */\r\nclass Receiver {\r\n  /**\r\n   * Creates a Receiver instance.\r\n   *\r\n   * @param {Object} extensions An object containing the negotiated extensions\r\n   * @param {Number} maxPayload The maximum allowed message length\r\n   * @param {String} binaryType The type for binary data\r\n   */\r\n  constructor (extensions, maxPayload, binaryType) {\r\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\r\n    this._extensions = extensions || {};\r\n    this._maxPayload = maxPayload | 0;\r\n\r\n    this._bufferedBytes = 0;\r\n    this._buffers = [];\r\n\r\n    this._compressed = false;\r\n    this._payloadLength = 0;\r\n    this._fragmented = 0;\r\n    this._masked = false;\r\n    this._fin = false;\r\n    this._mask = null;\r\n    this._opcode = 0;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragments = [];\r\n\r\n    this._cleanupCallback = null;\r\n    this._hadError = false;\r\n    this._dead = false;\r\n    this._loop = false;\r\n\r\n    this.onmessage = null;\r\n    this.onclose = null;\r\n    this.onerror = null;\r\n    this.onping = null;\r\n    this.onpong = null;\r\n\r\n    this._state = GET_INFO;\r\n  }\r\n\r\n  /**\r\n   * Consumes bytes from the available buffered data.\r\n   *\r\n   * @param {Number} bytes The number of bytes to consume\r\n   * @return {Buffer} Consumed bytes\r\n   * @private\r\n   */\r\n  readBuffer (bytes) {\r\n    var offset = 0;\r\n    var dst;\r\n    var l;\r\n\r\n    this._bufferedBytes -= bytes;\r\n\r\n    if (bytes === this._buffers[0].length) return this._buffers.shift();\r\n\r\n    if (bytes < this._buffers[0].length) {\r\n      dst = this._buffers[0].slice(0, bytes);\r\n      this._buffers[0] = this._buffers[0].slice(bytes);\r\n      return dst;\r\n    }\r\n\r\n    dst = Buffer.allocUnsafe(bytes);\r\n\r\n    while (bytes > 0) {\r\n      l = this._buffers[0].length;\r\n\r\n      if (bytes >= l) {\r\n        this._buffers[0].copy(dst, offset);\r\n        offset += l;\r\n        this._buffers.shift();\r\n      } else {\r\n        this._buffers[0].copy(dst, offset, 0, bytes);\r\n        this._buffers[0] = this._buffers[0].slice(bytes);\r\n      }\r\n\r\n      bytes -= l;\r\n    }\r\n\r\n    return dst;\r\n  }\r\n\r\n  /**\r\n   * Checks if the number of buffered bytes is bigger or equal than `n` and\r\n   * calls `cleanup` if necessary.\r\n   *\r\n   * @param {Number} n The number of bytes to check against\r\n   * @return {Boolean} `true` if `bufferedBytes >= n`, else `false`\r\n   * @private\r\n   */\r\n  hasBufferedBytes (n) {\r\n    if (this._bufferedBytes >= n) return true;\r\n\r\n    this._loop = false;\r\n    if (this._dead) this.cleanup(this._cleanupCallback);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Adds new data to the parser.\r\n   *\r\n   * @public\r\n   */\r\n  add (data) {\r\n    if (this._dead) return;\r\n\r\n    this._bufferedBytes += data.length;\r\n    this._buffers.push(data);\r\n    this.startLoop();\r\n  }\r\n\r\n  /**\r\n   * Starts the parsing loop.\r\n   *\r\n   * @private\r\n   */\r\n  startLoop () {\r\n    this._loop = true;\r\n\r\n    while (this._loop) {\r\n      switch (this._state) {\r\n        case GET_INFO:\r\n          this.getInfo();\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_16:\r\n          this.getPayloadLength16();\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_64:\r\n          this.getPayloadLength64();\r\n          break;\r\n        case GET_MASK:\r\n          this.getMask();\r\n          break;\r\n        case GET_DATA:\r\n          this.getData();\r\n          break;\r\n        default: // `INFLATING`\r\n          this._loop = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads the first two bytes of a frame.\r\n   *\r\n   * @private\r\n   */\r\n  getInfo () {\r\n    if (!this.hasBufferedBytes(2)) return;\r\n\r\n    const buf = this.readBuffer(2);\r\n\r\n    if ((buf[0] & 0x30) !== 0x00) {\r\n      this.error(new Error('RSV2 and RSV3 must be clear'), 1002);\r\n      return;\r\n    }\r\n\r\n    const compressed = (buf[0] & 0x40) === 0x40;\r\n\r\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\r\n      this.error(new Error('RSV1 must be clear'), 1002);\r\n      return;\r\n    }\r\n\r\n    this._fin = (buf[0] & 0x80) === 0x80;\r\n    this._opcode = buf[0] & 0x0f;\r\n    this._payloadLength = buf[1] & 0x7f;\r\n\r\n    if (this._opcode === 0x00) {\r\n      if (compressed) {\r\n        this.error(new Error('RSV1 must be clear'), 1002);\r\n        return;\r\n      }\r\n\r\n      if (!this._fragmented) {\r\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\r\n        return;\r\n      } else {\r\n        this._opcode = this._fragmented;\r\n      }\r\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\r\n      if (this._fragmented) {\r\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\r\n        return;\r\n      }\r\n\r\n      this._compressed = compressed;\r\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\r\n      if (!this._fin) {\r\n        this.error(new Error('FIN must be set'), 1002);\r\n        return;\r\n      }\r\n\r\n      if (compressed) {\r\n        this.error(new Error('RSV1 must be clear'), 1002);\r\n        return;\r\n      }\r\n\r\n      if (this._payloadLength > 0x7d) {\r\n        this.error(new Error('invalid payload length'), 1002);\r\n        return;\r\n      }\r\n    } else {\r\n      this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\r\n      return;\r\n    }\r\n\r\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\r\n\r\n    this._masked = (buf[1] & 0x80) === 0x80;\r\n\r\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\r\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\r\n    else this.haveLength();\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+16).\r\n   *\r\n   * @private\r\n   */\r\n  getPayloadLength16 () {\r\n    if (!this.hasBufferedBytes(2)) return;\r\n\r\n    this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\r\n    this.haveLength();\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+64).\r\n   *\r\n   * @private\r\n   */\r\n  getPayloadLength64 () {\r\n    if (!this.hasBufferedBytes(8)) return;\r\n\r\n    const buf = this.readBuffer(8);\r\n    const num = buf.readUInt32BE(0, true);\r\n\r\n    //\r\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\r\n    // if payload length is greater than this number.\r\n    //\r\n    if (num > Math.pow(2, 53 - 32) - 1) {\r\n      this.error(new Error('max payload size exceeded'), 1009);\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = (num * Math.pow(2, 32)) + buf.readUInt32BE(4, true);\r\n    this.haveLength();\r\n  }\r\n\r\n  /**\r\n   * Payload length has been read.\r\n   *\r\n   * @private\r\n   */\r\n  haveLength () {\r\n    if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\r\n      return;\r\n    }\r\n\r\n    if (this._masked) this._state = GET_MASK;\r\n    else this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads mask bytes.\r\n   *\r\n   * @private\r\n   */\r\n  getMask () {\r\n    if (!this.hasBufferedBytes(4)) return;\r\n\r\n    this._mask = this.readBuffer(4);\r\n    this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads data bytes.\r\n   *\r\n   * @private\r\n   */\r\n  getData () {\r\n    var data = constants.EMPTY_BUFFER;\r\n\r\n    if (this._payloadLength) {\r\n      if (!this.hasBufferedBytes(this._payloadLength)) return;\r\n\r\n      data = this.readBuffer(this._payloadLength);\r\n      if (this._masked) bufferUtil.unmask(data, this._mask);\r\n    }\r\n\r\n    if (this._opcode > 0x07) {\r\n      this.controlMessage(data);\r\n    } else if (this._compressed) {\r\n      this._state = INFLATING;\r\n      this.decompress(data);\r\n    } else if (this.pushFragment(data)) {\r\n      this.dataMessage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decompresses data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @private\r\n   */\r\n  decompress (data) {\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n\r\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\r\n      if (err) {\r\n        this.error(err, err.closeCode === 1009 ? 1009 : 1007);\r\n        return;\r\n      }\r\n\r\n      if (this.pushFragment(buf)) this.dataMessage();\r\n      this.startLoop();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles a data message.\r\n   *\r\n   * @private\r\n   */\r\n  dataMessage () {\r\n    if (this._fin) {\r\n      const messageLength = this._messageLength;\r\n      const fragments = this._fragments;\r\n\r\n      this._totalPayloadLength = 0;\r\n      this._messageLength = 0;\r\n      this._fragmented = 0;\r\n      this._fragments = [];\r\n\r\n      if (this._opcode === 2) {\r\n        var data;\r\n\r\n        if (this._binaryType === 'nodebuffer') {\r\n          data = toBuffer(fragments, messageLength);\r\n        } else if (this._binaryType === 'arraybuffer') {\r\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\r\n        } else {\r\n          data = fragments;\r\n        }\r\n\r\n        this.onmessage(data);\r\n      } else {\r\n        const buf = toBuffer(fragments, messageLength);\r\n\r\n        if (!isValidUTF8(buf)) {\r\n          this.error(new Error('invalid utf8 sequence'), 1007);\r\n          return;\r\n        }\r\n\r\n        this.onmessage(buf.toString());\r\n      }\r\n    }\r\n\r\n    this._state = GET_INFO;\r\n  }\r\n\r\n  /**\r\n   * Handles a control message.\r\n   *\r\n   * @param {Buffer} data Data to handle\r\n   * @private\r\n   */\r\n  controlMessage (data) {\r\n    if (this._opcode === 0x08) {\r\n      if (data.length === 0) {\r\n        this.onclose(1000, '');\r\n        this._loop = false;\r\n        this.cleanup(this._cleanupCallback);\r\n      } else if (data.length === 1) {\r\n        this.error(new Error('invalid payload length'), 1002);\r\n      } else {\r\n        const code = data.readUInt16BE(0, true);\r\n\r\n        if (!ErrorCodes.isValidErrorCode(code)) {\r\n          this.error(new Error(`invalid status code: ${code}`), 1002);\r\n          return;\r\n        }\r\n\r\n        const buf = data.slice(2);\r\n\r\n        if (!isValidUTF8(buf)) {\r\n          this.error(new Error('invalid utf8 sequence'), 1007);\r\n          return;\r\n        }\r\n\r\n        this.onclose(code, buf.toString());\r\n        this._loop = false;\r\n        this.cleanup(this._cleanupCallback);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (this._opcode === 0x09) this.onping(data);\r\n    else this.onpong(data);\r\n\r\n    this._state = GET_INFO;\r\n  }\r\n\r\n  /**\r\n   * Handles an error.\r\n   *\r\n   * @param {Error} err The error\r\n   * @param {Number} code Close code\r\n   * @private\r\n   */\r\n  error (err, code) {\r\n    this.onerror(err, code);\r\n    this._hadError = true;\r\n    this._loop = false;\r\n    this.cleanup(this._cleanupCallback);\r\n  }\r\n\r\n  /**\r\n   * Checks payload size, disconnects socket when it exceeds `maxPayload`.\r\n   *\r\n   * @param {Number} length Payload length\r\n   * @private\r\n   */\r\n  maxPayloadExceeded (length) {\r\n    if (length === 0 || this._maxPayload < 1) return false;\r\n\r\n    const fullLength = this._totalPayloadLength + length;\r\n\r\n    if (fullLength <= this._maxPayload) {\r\n      this._totalPayloadLength = fullLength;\r\n      return false;\r\n    }\r\n\r\n    this.error(new Error('max payload size exceeded'), 1009);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Appends a fragment in the fragments array after checking that the sum of\r\n   * fragment lengths does not exceed `maxPayload`.\r\n   *\r\n   * @param {Buffer} fragment The fragment to add\r\n   * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\r\n   * @private\r\n   */\r\n  pushFragment (fragment) {\r\n    if (fragment.length === 0) return true;\r\n\r\n    const totalLength = this._messageLength + fragment.length;\r\n\r\n    if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\r\n      this._messageLength = totalLength;\r\n      this._fragments.push(fragment);\r\n      return true;\r\n    }\r\n\r\n    this.error(new Error('max payload size exceeded'), 1009);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Releases resources used by the receiver.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  cleanup (cb) {\r\n    this._dead = true;\r\n\r\n    if (!this._hadError && (this._loop || this._state === INFLATING)) {\r\n      this._cleanupCallback = cb;\r\n    } else {\r\n      this._extensions = null;\r\n      this._fragments = null;\r\n      this._buffers = null;\r\n      this._mask = null;\r\n\r\n      this._cleanupCallback = null;\r\n      this.onmessage = null;\r\n      this.onclose = null;\r\n      this.onerror = null;\r\n      this.onping = null;\r\n      this.onpong = null;\r\n\r\n      if (cb) cb();\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Receiver;\r\n\r\n/**\r\n * Makes a buffer from a list of fragments.\r\n *\r\n * @param {Buffer[]} fragments The list of fragments composing the message\r\n * @param {Number} messageLength The length of the message\r\n * @return {Buffer}\r\n * @private\r\n */\r\nfunction toBuffer (fragments, messageLength) {\r\n  if (fragments.length === 1) return fragments[0];\r\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\r\n  return constants.EMPTY_BUFFER;\r\n}\r\n\r\n/**\r\n * Converts a buffer to an `ArrayBuffer`.\r\n *\r\n * @param {Buffer} The buffer to convert\r\n * @return {ArrayBuffer} Converted buffer\r\n */\r\nfunction toArrayBuffer (buf) {\r\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\r\n    return buf.buffer;\r\n  }\r\n\r\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\r\n}\r\n","/*!\r\n * ws: a node.js websocket client\r\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\ntry {\r\n  const isValidUTF8 = require('utf-8-validate');\r\n\r\n  module.exports = typeof isValidUTF8 === 'object'\r\n    ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\r\n    : isValidUTF8;\r\n} catch (e) /* istanbul ignore next */ {\r\n  module.exports = () => true;\r\n}\r\n","/*!\r\n * ws: a node.js websocket client\r\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\nmodule.exports = {\r\n  isValidErrorCode: function (code) {\r\n    return (code >= 1000 && code <= 1013 && code !== 1004 && code !== 1005 && code !== 1006) ||\r\n      (code >= 3000 && code <= 4999);\r\n  },\r\n  1000: 'normal',\r\n  1001: 'going away',\r\n  1002: 'protocol error',\r\n  1003: 'unsupported data',\r\n  1004: 'reserved',\r\n  1005: 'reserved for extensions',\r\n  1006: 'reserved for extensions',\r\n  1007: 'inconsistent or invalid data',\r\n  1008: 'policy violation',\r\n  1009: 'message too big',\r\n  1010: 'extension handshake missing',\r\n  1011: 'an unexpected condition prevented the request from being fulfilled',\r\n  1012: 'service restart',\r\n  1013: 'try again later'\r\n};\r\n","/*!\r\n * ws: a node.js websocket client\r\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\nconst safeBuffer = require('safe-buffer');\r\nconst crypto = require('crypto');\r\n\r\nconst PerMessageDeflate = require('./PerMessageDeflate');\r\nconst bufferUtil = require('./BufferUtil');\r\nconst ErrorCodes = require('./ErrorCodes');\r\nconst constants = require('./Constants');\r\n\r\nconst Buffer = safeBuffer.Buffer;\r\n\r\n/**\r\n * HyBi Sender implementation.\r\n */\r\nclass Sender {\r\n  /**\r\n   * Creates a Sender instance.\r\n   *\r\n   * @param {net.Socket} socket The connection socket\r\n   * @param {Object} extensions An object containing the negotiated extensions\r\n   */\r\n  constructor (socket, extensions) {\r\n    this._extensions = extensions || {};\r\n    this._socket = socket;\r\n\r\n    this._firstFragment = true;\r\n    this._compress = false;\r\n\r\n    this._bufferedBytes = 0;\r\n    this._deflating = false;\r\n    this._queue = [];\r\n  }\r\n\r\n  /**\r\n   * Frames a piece of data according to the HyBi WebSocket protocol.\r\n   *\r\n   * @param {Buffer} data The data to frame\r\n   * @param {Object} options Options object\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\r\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\r\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\r\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\r\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\r\n   * @public\r\n   */\r\n  static frame (data, options) {\r\n    const merge = data.length < 1024 || (options.mask && options.readOnly);\r\n    var offset = options.mask ? 6 : 2;\r\n    var payloadLength = data.length;\r\n\r\n    if (data.length >= 65536) {\r\n      offset += 8;\r\n      payloadLength = 127;\r\n    } else if (data.length > 125) {\r\n      offset += 2;\r\n      payloadLength = 126;\r\n    }\r\n\r\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\r\n\r\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\r\n    if (options.rsv1) target[0] |= 0x40;\r\n\r\n    if (payloadLength === 126) {\r\n      target.writeUInt16BE(data.length, 2, true);\r\n    } else if (payloadLength === 127) {\r\n      target.writeUInt32BE(0, 2, true);\r\n      target.writeUInt32BE(data.length, 6, true);\r\n    }\r\n\r\n    if (!options.mask) {\r\n      target[1] = payloadLength;\r\n      if (merge) {\r\n        data.copy(target, offset);\r\n        return [target];\r\n      }\r\n\r\n      return [target, data];\r\n    }\r\n\r\n    const mask = crypto.randomBytes(4);\r\n\r\n    target[1] = payloadLength | 0x80;\r\n    target[offset - 4] = mask[0];\r\n    target[offset - 3] = mask[1];\r\n    target[offset - 2] = mask[2];\r\n    target[offset - 1] = mask[3];\r\n\r\n    if (merge) {\r\n      bufferUtil.mask(data, mask, target, offset, data.length);\r\n      return [target];\r\n    }\r\n\r\n    bufferUtil.mask(data, mask, data, 0, data.length);\r\n    return [target, data];\r\n  }\r\n\r\n  /**\r\n   * Sends a close message to the other peer.\r\n   *\r\n   * @param {(Number|undefined)} code The status code component of the body\r\n   * @param {String} data The message component of the body\r\n   * @param {Boolean} mask Specifies whether or not to mask the message\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  close (code, data, mask, cb) {\r\n    var buf;\r\n\r\n    if (code === undefined) {\r\n      code = 1000;\r\n    } else if (typeof code !== 'number' || !ErrorCodes.isValidErrorCode(code)) {\r\n      throw new Error('first argument must be a valid error code number');\r\n    }\r\n\r\n    if (data === undefined || data === '') {\r\n      if (code === 1000) {\r\n        buf = constants.EMPTY_BUFFER;\r\n      } else {\r\n        buf = Buffer.allocUnsafe(2);\r\n        buf.writeUInt16BE(code, 0, true);\r\n      }\r\n    } else {\r\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\r\n      buf.writeUInt16BE(code, 0, true);\r\n      buf.write(data, 2);\r\n    }\r\n\r\n    if (this._deflating) {\r\n      this.enqueue([this.doClose, buf, mask, cb]);\r\n    } else {\r\n      this.doClose(buf, mask, cb);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Frames and sends a close message.\r\n   *\r\n   * @param {Buffer} data The message to send\r\n   * @param {Boolean} mask Specifies whether or not to mask `data`\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  doClose (data, mask, cb) {\r\n    this.sendFrame(Sender.frame(data, {\r\n      fin: true,\r\n      rsv1: false,\r\n      opcode: 0x08,\r\n      mask,\r\n      readOnly: false\r\n    }), cb);\r\n  }\r\n\r\n  /**\r\n   * Sends a ping message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} mask Specifies whether or not to mask `data`\r\n   * @public\r\n   */\r\n  ping (data, mask) {\r\n    var readOnly = true;\r\n\r\n    if (!Buffer.isBuffer(data)) {\r\n      if (data instanceof ArrayBuffer) {\r\n        data = Buffer.from(data);\r\n      } else if (ArrayBuffer.isView(data)) {\r\n        data = viewToBuffer(data);\r\n      } else {\r\n        data = Buffer.from(data);\r\n        readOnly = false;\r\n      }\r\n    }\r\n\r\n    if (this._deflating) {\r\n      this.enqueue([this.doPing, data, mask, readOnly]);\r\n    } else {\r\n      this.doPing(data, mask, readOnly);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Frames and sends a ping message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} mask Specifies whether or not to mask `data`\r\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\r\n   * @private\r\n   */\r\n  doPing (data, mask, readOnly) {\r\n    this.sendFrame(Sender.frame(data, {\r\n      fin: true,\r\n      rsv1: false,\r\n      opcode: 0x09,\r\n      mask,\r\n      readOnly\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Sends a pong message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} mask Specifies whether or not to mask `data`\r\n   * @public\r\n   */\r\n  pong (data, mask) {\r\n    var readOnly = true;\r\n\r\n    if (!Buffer.isBuffer(data)) {\r\n      if (data instanceof ArrayBuffer) {\r\n        data = Buffer.from(data);\r\n      } else if (ArrayBuffer.isView(data)) {\r\n        data = viewToBuffer(data);\r\n      } else {\r\n        data = Buffer.from(data);\r\n        readOnly = false;\r\n      }\r\n    }\r\n\r\n    if (this._deflating) {\r\n      this.enqueue([this.doPong, data, mask, readOnly]);\r\n    } else {\r\n      this.doPong(data, mask, readOnly);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Frames and sends a pong message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} mask Specifies whether or not to mask `data`\r\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\r\n   * @private\r\n   */\r\n  doPong (data, mask, readOnly) {\r\n    this.sendFrame(Sender.frame(data, {\r\n      fin: true,\r\n      rsv1: false,\r\n      opcode: 0x0a,\r\n      mask,\r\n      readOnly\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Sends a data message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\r\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\r\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\r\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  send (data, options, cb) {\r\n    var opcode = options.binary ? 2 : 1;\r\n    var rsv1 = options.compress;\r\n    var readOnly = true;\r\n\r\n    if (!Buffer.isBuffer(data)) {\r\n      if (data instanceof ArrayBuffer) {\r\n        data = Buffer.from(data);\r\n      } else if (ArrayBuffer.isView(data)) {\r\n        data = viewToBuffer(data);\r\n      } else {\r\n        data = Buffer.from(data);\r\n        readOnly = false;\r\n      }\r\n    }\r\n\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n\r\n    if (this._firstFragment) {\r\n      this._firstFragment = false;\r\n      if (rsv1 && perMessageDeflate) {\r\n        rsv1 = data.length >= perMessageDeflate._threshold;\r\n      }\r\n      this._compress = rsv1;\r\n    } else {\r\n      rsv1 = false;\r\n      opcode = 0;\r\n    }\r\n\r\n    if (options.fin) this._firstFragment = true;\r\n\r\n    if (perMessageDeflate) {\r\n      const opts = {\r\n        fin: options.fin,\r\n        rsv1,\r\n        opcode,\r\n        mask: options.mask,\r\n        readOnly\r\n      };\r\n\r\n      if (this._deflating) {\r\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\r\n      } else {\r\n        this.dispatch(data, this._compress, opts, cb);\r\n      }\r\n    } else {\r\n      this.sendFrame(Sender.frame(data, {\r\n        fin: options.fin,\r\n        rsv1: false,\r\n        opcode,\r\n        mask: options.mask,\r\n        readOnly\r\n      }), cb);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispatches a data message.\r\n   *\r\n   * @param {Buffer} data The message to send\r\n   * @param {Boolean} compress Specifies whether or not to compress `data`\r\n   * @param {Object} options Options object\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\r\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\r\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\r\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  dispatch (data, compress, options, cb) {\r\n    if (!compress) {\r\n      this.sendFrame(Sender.frame(data, options), cb);\r\n      return;\r\n    }\r\n\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n\r\n    this._deflating = true;\r\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\r\n      options.readOnly = false;\r\n      this.sendFrame(Sender.frame(buf, options), cb);\r\n      this._deflating = false;\r\n      this.dequeue();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes queued send operations.\r\n   *\r\n   * @private\r\n   */\r\n  dequeue () {\r\n    while (!this._deflating && this._queue.length) {\r\n      const params = this._queue.shift();\r\n\r\n      this._bufferedBytes -= params[1].length;\r\n      params[0].apply(this, params.slice(1));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enqueues a send operation.\r\n   *\r\n   * @param {Array} params Send operation parameters.\r\n   * @private\r\n   */\r\n  enqueue (params) {\r\n    this._bufferedBytes += params[1].length;\r\n    this._queue.push(params);\r\n  }\r\n\r\n  /**\r\n   * Sends a frame.\r\n   *\r\n   * @param {Buffer[]} list The frame to send\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  sendFrame (list, cb) {\r\n    if (list.length === 2) {\r\n      this._socket.write(list[0]);\r\n      this._socket.write(list[1], cb);\r\n    } else {\r\n      this._socket.write(list[0], cb);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Sender;\r\n\r\n/**\r\n * Converts an `ArrayBuffer` view into a buffer.\r\n *\r\n * @param {(DataView|TypedArray)} view The view to convert\r\n * @return {Buffer} Converted view\r\n * @private\r\n */\r\nfunction viewToBuffer (view) {\r\n  const buf = Buffer.from(view.buffer);\r\n\r\n  if (view.byteLength !== view.buffer.byteLength) {\r\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\r\n  }\r\n\r\n  return buf;\r\n}\r\n","/*!\r\n * ws: a node.js websocket client\r\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\nconst safeBuffer = require('safe-buffer');\r\nconst EventEmitter = require('events');\r\nconst crypto = require('crypto');\r\nconst Ultron = require('ultron');\r\nconst http = require('http');\r\nconst url = require('url');\r\n\r\nconst PerMessageDeflate = require('./PerMessageDeflate');\r\nconst Extensions = require('./Extensions');\r\nconst constants = require('./Constants');\r\nconst WebSocket = require('./WebSocket');\r\n\r\nconst Buffer = safeBuffer.Buffer;\r\n\r\n/**\r\n * Class representing a WebSocket server.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocketServer extends EventEmitter {\r\n  /**\r\n   * Create a `WebSocketServer` instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {String} options.host The hostname where to bind the server\r\n   * @param {Number} options.port The port where to bind the server\r\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\r\n   * @param {Function} options.verifyClient An hook to reject connections\r\n   * @param {Function} options.handleProtocols An hook to handle protocols\r\n   * @param {String} options.path Accept only connections matching this path\r\n   * @param {Boolean} options.noServer Enable no server mode\r\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\r\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\r\n   * @param {Number} options.maxPayload The maximum allowed message size\r\n   * @param {Function} callback A listener for the `listening` event\r\n   */\r\n  constructor (options, callback) {\r\n    super();\r\n\r\n    options = Object.assign({\r\n      maxPayload: 100 * 1024 * 1024,\r\n      perMessageDeflate: false,\r\n      handleProtocols: null,\r\n      clientTracking: true,\r\n      verifyClient: null,\r\n      noServer: false,\r\n      backlog: null, // use default (511 as implemented in net.js)\r\n      server: null,\r\n      host: null,\r\n      path: null,\r\n      port: null\r\n    }, options);\r\n\r\n    if (options.port == null && !options.server && !options.noServer) {\r\n      throw new TypeError('missing or invalid options');\r\n    }\r\n\r\n    if (options.port != null) {\r\n      this._server = http.createServer((req, res) => {\r\n        const body = http.STATUS_CODES[426];\r\n\r\n        res.writeHead(426, {\r\n          'Content-Length': body.length,\r\n          'Content-Type': 'text/plain'\r\n        });\r\n        res.end(body);\r\n      });\r\n      this._server.listen(options.port, options.host, options.backlog, callback);\r\n    } else if (options.server) {\r\n      this._server = options.server;\r\n    }\r\n\r\n    if (this._server) {\r\n      this._ultron = new Ultron(this._server);\r\n      this._ultron.on('listening', () => this.emit('listening'));\r\n      this._ultron.on('error', (err) => this.emit('error', err));\r\n      this._ultron.on('upgrade', (req, socket, head) => {\r\n        this.handleUpgrade(req, socket, head, (client) => {\r\n          this.emit('connection', client, req);\r\n        });\r\n      });\r\n    }\r\n\r\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\r\n    if (options.clientTracking) this.clients = new Set();\r\n    this.options = options;\r\n  }\r\n\r\n  /**\r\n   * Close the server.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  close (cb) {\r\n    //\r\n    // Terminate all associated clients.\r\n    //\r\n    if (this.clients) {\r\n      for (const client of this.clients) client.terminate();\r\n    }\r\n\r\n    const server = this._server;\r\n\r\n    if (server) {\r\n      this._ultron.destroy();\r\n      this._ultron = this._server = null;\r\n\r\n      //\r\n      // Close the http server if it was internally created.\r\n      //\r\n      if (this.options.port != null) return server.close(cb);\r\n    }\r\n\r\n    if (cb) cb();\r\n  }\r\n\r\n  /**\r\n   * See if a given request should be handled by this server instance.\r\n   *\r\n   * @param {http.IncomingMessage} req Request object to inspect\r\n   * @return {Boolean} `true` if the request is valid, else `false`\r\n   * @public\r\n   */\r\n  shouldHandle (req) {\r\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Handle a HTTP Upgrade request.\r\n   *\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {net.Socket} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  handleUpgrade (req, socket, head, cb) {\r\n    socket.on('error', socketError);\r\n\r\n    const version = +req.headers['sec-websocket-version'];\r\n    const extensions = {};\r\n\r\n    if (\r\n      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||\r\n      !req.headers['sec-websocket-key'] || (version !== 8 && version !== 13) ||\r\n      !this.shouldHandle(req)\r\n    ) {\r\n      return abortConnection(socket, 400);\r\n    }\r\n\r\n    if (this.options.perMessageDeflate) {\r\n      const perMessageDeflate = new PerMessageDeflate(\r\n        this.options.perMessageDeflate,\r\n        true,\r\n        this.options.maxPayload\r\n      );\r\n\r\n      try {\r\n        const offers = Extensions.parse(\r\n          req.headers['sec-websocket-extensions']\r\n        );\r\n\r\n        if (offers[PerMessageDeflate.extensionName]) {\r\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\r\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\r\n        }\r\n      } catch (err) {\r\n        return abortConnection(socket, 400);\r\n      }\r\n    }\r\n\r\n    var protocol = (req.headers['sec-websocket-protocol'] || '').split(/, */);\r\n\r\n    //\r\n    // Optionally call external protocol selection handler.\r\n    //\r\n    if (this.options.handleProtocols) {\r\n      protocol = this.options.handleProtocols(protocol, req);\r\n      if (protocol === false) return abortConnection(socket, 401);\r\n    } else {\r\n      protocol = protocol[0];\r\n    }\r\n\r\n    //\r\n    // Optionally call external client verification handler.\r\n    //\r\n    if (this.options.verifyClient) {\r\n      const info = {\r\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\r\n        secure: !!(req.connection.authorized || req.connection.encrypted),\r\n        req\r\n      };\r\n\r\n      if (this.options.verifyClient.length === 2) {\r\n        this.options.verifyClient(info, (verified, code, message) => {\r\n          if (!verified) return abortConnection(socket, code || 401, message);\r\n\r\n          this.completeUpgrade(\r\n            protocol,\r\n            extensions,\r\n            version,\r\n            req,\r\n            socket,\r\n            head,\r\n            cb\r\n          );\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (!this.options.verifyClient(info)) return abortConnection(socket, 401);\r\n    }\r\n\r\n    this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\r\n  }\r\n\r\n  /**\r\n   * Upgrade the connection to WebSocket.\r\n   *\r\n   * @param {String} protocol The chosen subprotocol\r\n   * @param {Object} extensions The accepted extensions\r\n   * @param {Number} version The WebSocket protocol version\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {net.Socket} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  completeUpgrade (protocol, extensions, version, req, socket, head, cb) {\r\n    //\r\n    // Destroy the socket if the client has already sent a FIN packet.\r\n    //\r\n    if (!socket.readable || !socket.writable) return socket.destroy();\r\n\r\n    const key = crypto.createHash('sha1')\r\n      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')\r\n      .digest('base64');\r\n\r\n    const headers = [\r\n      'HTTP/1.1 101 Switching Protocols',\r\n      'Upgrade: websocket',\r\n      'Connection: Upgrade',\r\n      `Sec-WebSocket-Accept: ${key}`\r\n    ];\r\n\r\n    if (protocol) headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\r\n    if (extensions[PerMessageDeflate.extensionName]) {\r\n      const params = extensions[PerMessageDeflate.extensionName].params;\r\n      const value = Extensions.format({\r\n        [PerMessageDeflate.extensionName]: [params]\r\n      });\r\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\r\n    }\r\n\r\n    //\r\n    // Allow external modification/inspection of handshake headers.\r\n    //\r\n    this.emit('headers', headers, req);\r\n\r\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\r\n\r\n    const client = new WebSocket([socket, head], null, {\r\n      maxPayload: this.options.maxPayload,\r\n      protocolVersion: version,\r\n      extensions,\r\n      protocol\r\n    });\r\n\r\n    if (this.clients) {\r\n      this.clients.add(client);\r\n      client.on('close', () => this.clients.delete(client));\r\n    }\r\n\r\n    socket.removeListener('error', socketError);\r\n    cb(client);\r\n  }\r\n}\r\n\r\nmodule.exports = WebSocketServer;\r\n\r\n/**\r\n * Handle premature socket errors.\r\n *\r\n * @private\r\n */\r\nfunction socketError () {\r\n  this.destroy();\r\n}\r\n\r\n/**\r\n * Close the connection when preconditions are not fulfilled.\r\n *\r\n * @param {net.Socket} socket The socket of the upgrade request\r\n * @param {Number} code The HTTP response status code\r\n * @param {String} [message] The HTTP response body\r\n * @private\r\n */\r\nfunction abortConnection (socket, code, message) {\r\n  if (socket.writable) {\r\n    message = message || http.STATUS_CODES[code];\r\n    socket.write(\r\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\r\n      'Connection: close\\r\\n' +\r\n      'Content-type: text/html\\r\\n' +\r\n      `Content-Length: ${Buffer.byteLength(message)}\\r\\n` +\r\n      '\\r\\n' +\r\n      message\r\n    );\r\n  }\r\n\r\n  socket.removeListener('error', socketError);\r\n  socket.destroy();\r\n}\r\n"]}