{"version":3,"sources":["index.js","socket.js","transports\\index.js","transports\\polling-xhr.js","transports\\polling.js","transport.js","transports\\polling-jsonp.js","transports\\websocket.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,AIZA,AHSA,ACHA,ACHA;AHUA,AIZA,AHSA,ACHA,ACHA;AHUA,AIZA,AHSA,ACHA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,AHSA,AIZA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AIZA,ACHA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AKfA,AHSA,ACHA,AGTA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA,AIZA;ANmBA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nmodule.exports = require('./socket');\r\n\r\n/**\r\n * Exports parser\r\n *\r\n * @api public\r\n *\r\n */\r\nmodule.exports.parser = require('engine.io-parser');\r\n","/**\r\n * Module dependencies.\r\n */\r\n\r\nvar transports = require('./transports/index');\r\nvar Emitter = require('component-emitter');\r\nvar debug = require('debug')('engine.io-client:socket');\r\nvar index = require('indexof');\r\nvar parser = require('engine.io-parser');\r\nvar parseuri = require('parseuri');\r\nvar parseqs = require('parseqs');\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = Socket;\r\n\r\n/**\r\n * Socket constructor.\r\n *\r\n * @param {String|Object} uri or options\r\n * @param {Object} options\r\n * @api public\r\n */\r\n\r\nfunction Socket (uri, opts) {\r\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\r\n\r\n  opts = opts || {};\r\n\r\n  if (uri && 'object' === typeof uri) {\r\n    opts = uri;\r\n    uri = null;\r\n  }\r\n\r\n  if (uri) {\r\n    uri = parseuri(uri);\r\n    opts.hostname = uri.host;\r\n    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';\r\n    opts.port = uri.port;\r\n    if (uri.query) opts.query = uri.query;\r\n  } else if (opts.host) {\r\n    opts.hostname = parseuri(opts.host).host;\r\n  }\r\n\r\n  this.secure = null != opts.secure ? opts.secure\r\n    : (typeof location !== 'undefined' && 'https:' === location.protocol);\r\n\r\n  if (opts.hostname && !opts.port) {\r\n    // if no port is specified manually, use the protocol default\r\n    opts.port = this.secure ? '443' : '80';\r\n  }\r\n\r\n  this.agent = opts.agent || false;\r\n  this.hostname = opts.hostname ||\r\n    (typeof location !== 'undefined' ? location.hostname : 'localhost');\r\n  this.port = opts.port || (typeof location !== 'undefined' && location.port\r\n      ? location.port\r\n      : (this.secure ? 443 : 80));\r\n  this.query = opts.query || {};\r\n  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);\r\n  this.upgrade = false !== opts.upgrade;\r\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\r\n  this.forceJSONP = !!opts.forceJSONP;\r\n  this.jsonp = false !== opts.jsonp;\r\n  this.forceBase64 = !!opts.forceBase64;\r\n  this.enablesXDR = !!opts.enablesXDR;\r\n  this.withCredentials = false !== opts.withCredentials;\r\n  this.timestampParam = opts.timestampParam || 't';\r\n  this.timestampRequests = opts.timestampRequests;\r\n  this.transports = opts.transports || ['polling', 'websocket'];\r\n  this.transportOptions = opts.transportOptions || {};\r\n  this.readyState = '';\r\n  this.writeBuffer = [];\r\n  this.prevBufferLen = 0;\r\n  this.policyPort = opts.policyPort || 843;\r\n  this.rememberUpgrade = opts.rememberUpgrade || false;\r\n  this.binaryType = null;\r\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\r\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\r\n\r\n  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\r\n  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\r\n    this.perMessageDeflate.threshold = 1024;\r\n  }\r\n\r\n  // SSL options for Node.js client\r\n  this.pfx = opts.pfx || null;\r\n  this.key = opts.key || null;\r\n  this.passphrase = opts.passphrase || null;\r\n  this.cert = opts.cert || null;\r\n  this.ca = opts.ca || null;\r\n  this.ciphers = opts.ciphers || null;\r\n  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;\r\n  this.forceNode = !!opts.forceNode;\r\n\r\n  // detect ReactNative environment\r\n  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');\r\n\r\n  // other options for Node.js or ReactNative client\r\n  if (typeof self === 'undefined' || this.isReactNative) {\r\n    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\r\n      this.extraHeaders = opts.extraHeaders;\r\n    }\r\n\r\n    if (opts.localAddress) {\r\n      this.localAddress = opts.localAddress;\r\n    }\r\n  }\r\n\r\n  // set on handshake\r\n  this.id = null;\r\n  this.upgrades = null;\r\n  this.pingInterval = null;\r\n  this.pingTimeout = null;\r\n\r\n  // set on heartbeat\r\n  this.pingIntervalTimer = null;\r\n  this.pingTimeoutTimer = null;\r\n\r\n  this.open();\r\n}\r\n\r\nSocket.priorWebsocketSuccess = false;\r\n\r\n/**\r\n * Mix in `Emitter`.\r\n */\r\n\r\nEmitter(Socket.prototype);\r\n\r\n/**\r\n * Protocol version.\r\n *\r\n * @api public\r\n */\r\n\r\nSocket.protocol = parser.protocol; // this is an int\r\n\r\n/**\r\n * Expose deps for legacy compatibility\r\n * and standalone browser access.\r\n */\r\n\r\nSocket.Socket = Socket;\r\nSocket.Transport = require('./transport');\r\nSocket.transports = require('./transports/index');\r\nSocket.parser = require('engine.io-parser');\r\n\r\n/**\r\n * Creates transport of the given type.\r\n *\r\n * @param {String} transport name\r\n * @return {Transport}\r\n * @api private\r\n */\r\n\r\nSocket.prototype.createTransport = function (name) {\r\n  debug('creating transport \"%s\"', name);\r\n  var query = clone(this.query);\r\n\r\n  // append engine.io protocol identifier\r\n  query.EIO = parser.protocol;\r\n\r\n  // transport name\r\n  query.transport = name;\r\n\r\n  // per-transport options\r\n  var options = this.transportOptions[name] || {};\r\n\r\n  // session id if we already have one\r\n  if (this.id) query.sid = this.id;\r\n\r\n  var transport = new transports[name]({\r\n    query: query,\r\n    socket: this,\r\n    agent: options.agent || this.agent,\r\n    hostname: options.hostname || this.hostname,\r\n    port: options.port || this.port,\r\n    secure: options.secure || this.secure,\r\n    path: options.path || this.path,\r\n    forceJSONP: options.forceJSONP || this.forceJSONP,\r\n    jsonp: options.jsonp || this.jsonp,\r\n    forceBase64: options.forceBase64 || this.forceBase64,\r\n    enablesXDR: options.enablesXDR || this.enablesXDR,\r\n    withCredentials: options.withCredentials || this.withCredentials,\r\n    timestampRequests: options.timestampRequests || this.timestampRequests,\r\n    timestampParam: options.timestampParam || this.timestampParam,\r\n    policyPort: options.policyPort || this.policyPort,\r\n    pfx: options.pfx || this.pfx,\r\n    key: options.key || this.key,\r\n    passphrase: options.passphrase || this.passphrase,\r\n    cert: options.cert || this.cert,\r\n    ca: options.ca || this.ca,\r\n    ciphers: options.ciphers || this.ciphers,\r\n    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,\r\n    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,\r\n    extraHeaders: options.extraHeaders || this.extraHeaders,\r\n    forceNode: options.forceNode || this.forceNode,\r\n    localAddress: options.localAddress || this.localAddress,\r\n    requestTimeout: options.requestTimeout || this.requestTimeout,\r\n    protocols: options.protocols || void (0),\r\n    isReactNative: this.isReactNative\r\n  });\r\n\r\n  return transport;\r\n};\r\n\r\nfunction clone (obj) {\r\n  var o = {};\r\n  for (var i in obj) {\r\n    if (obj.hasOwnProperty(i)) {\r\n      o[i] = obj[i];\r\n    }\r\n  }\r\n  return o;\r\n}\r\n\r\n/**\r\n * Initializes transport to use and starts probe.\r\n *\r\n * @api private\r\n */\r\nSocket.prototype.open = function () {\r\n  var transport;\r\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {\r\n    transport = 'websocket';\r\n  } else if (0 === this.transports.length) {\r\n    // Emit error on next tick so it can be listened to\r\n    var self = this;\r\n    setTimeout(function () {\r\n      self.emit('error', 'No transports available');\r\n    }, 0);\r\n    return;\r\n  } else {\r\n    transport = this.transports[0];\r\n  }\r\n  this.readyState = 'opening';\r\n\r\n  // Retry with the next transport if the transport is disabled (jsonp: false)\r\n  try {\r\n    transport = this.createTransport(transport);\r\n  } catch (e) {\r\n    this.transports.shift();\r\n    this.open();\r\n    return;\r\n  }\r\n\r\n  transport.open();\r\n  this.setTransport(transport);\r\n};\r\n\r\n/**\r\n * Sets the current transport. Disables the existing one (if any).\r\n *\r\n * @api private\r\n */\r\n\r\nSocket.prototype.setTransport = function (transport) {\r\n  debug('setting transport %s', transport.name);\r\n  var self = this;\r\n\r\n  if (this.transport) {\r\n    debug('clearing existing transport %s', this.transport.name);\r\n    this.transport.removeAllListeners();\r\n  }\r\n\r\n  // set up transport\r\n  this.transport = transport;\r\n\r\n  // set up transport listeners\r\n  transport\r\n  .on('drain', function () {\r\n    self.onDrain();\r\n  })\r\n  .on('packet', function (packet) {\r\n    self.onPacket(packet);\r\n  })\r\n  .on('error', function (e) {\r\n    self.onError(e);\r\n  })\r\n  .on('close', function () {\r\n    self.onClose('transport close');\r\n  });\r\n};\r\n\r\n/**\r\n * Probes a transport.\r\n *\r\n * @param {String} transport name\r\n * @api private\r\n */\r\n\r\nSocket.prototype.probe = function (name) {\r\n  debug('probing transport \"%s\"', name);\r\n  var transport = this.createTransport(name, { probe: 1 });\r\n  var failed = false;\r\n  var self = this;\r\n\r\n  Socket.priorWebsocketSuccess = false;\r\n\r\n  function onTransportOpen () {\r\n    if (self.onlyBinaryUpgrades) {\r\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\r\n      failed = failed || upgradeLosesBinary;\r\n    }\r\n    if (failed) return;\r\n\r\n    debug('probe transport \"%s\" opened', name);\r\n    transport.send([{ type: 'ping', data: 'probe' }]);\r\n    transport.once('packet', function (msg) {\r\n      if (failed) return;\r\n      if ('pong' === msg.type && 'probe' === msg.data) {\r\n        debug('probe transport \"%s\" pong', name);\r\n        self.upgrading = true;\r\n        self.emit('upgrading', transport);\r\n        if (!transport) return;\r\n        Socket.priorWebsocketSuccess = 'websocket' === transport.name;\r\n\r\n        debug('pausing current transport \"%s\"', self.transport.name);\r\n        self.transport.pause(function () {\r\n          if (failed) return;\r\n          if ('closed' === self.readyState) return;\r\n          debug('changing transport and sending upgrade packet');\r\n\r\n          cleanup();\r\n\r\n          self.setTransport(transport);\r\n          transport.send([{ type: 'upgrade' }]);\r\n          self.emit('upgrade', transport);\r\n          transport = null;\r\n          self.upgrading = false;\r\n          self.flush();\r\n        });\r\n      } else {\r\n        debug('probe transport \"%s\" failed', name);\r\n        var err = new Error('probe error');\r\n        err.transport = transport.name;\r\n        self.emit('upgradeError', err);\r\n      }\r\n    });\r\n  }\r\n\r\n  function freezeTransport () {\r\n    if (failed) return;\r\n\r\n    // Any callback called by transport should be ignored since now\r\n    failed = true;\r\n\r\n    cleanup();\r\n\r\n    transport.close();\r\n    transport = null;\r\n  }\r\n\r\n  // Handle any error that happens while probing\r\n  function onerror (err) {\r\n    var error = new Error('probe error: ' + err);\r\n    error.transport = transport.name;\r\n\r\n    freezeTransport();\r\n\r\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\r\n\r\n    self.emit('upgradeError', error);\r\n  }\r\n\r\n  function onTransportClose () {\r\n    onerror('transport closed');\r\n  }\r\n\r\n  // When the socket is closed while we're probing\r\n  function onclose () {\r\n    onerror('socket closed');\r\n  }\r\n\r\n  // When the socket is upgraded while we're probing\r\n  function onupgrade (to) {\r\n    if (transport && to.name !== transport.name) {\r\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\r\n      freezeTransport();\r\n    }\r\n  }\r\n\r\n  // Remove all listeners on the transport and on self\r\n  function cleanup () {\r\n    transport.removeListener('open', onTransportOpen);\r\n    transport.removeListener('error', onerror);\r\n    transport.removeListener('close', onTransportClose);\r\n    self.removeListener('close', onclose);\r\n    self.removeListener('upgrading', onupgrade);\r\n  }\r\n\r\n  transport.once('open', onTransportOpen);\r\n  transport.once('error', onerror);\r\n  transport.once('close', onTransportClose);\r\n\r\n  this.once('close', onclose);\r\n  this.once('upgrading', onupgrade);\r\n\r\n  transport.open();\r\n};\r\n\r\n/**\r\n * Called when connection is deemed open.\r\n *\r\n * @api public\r\n */\r\n\r\nSocket.prototype.onOpen = function () {\r\n  debug('socket open');\r\n  this.readyState = 'open';\r\n  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;\r\n  this.emit('open');\r\n  this.flush();\r\n\r\n  // we check for `readyState` in case an `open`\r\n  // listener already closed the socket\r\n  if ('open' === this.readyState && this.upgrade && this.transport.pause) {\r\n    debug('starting upgrade probes');\r\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\r\n      this.probe(this.upgrades[i]);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Handles a packet.\r\n *\r\n * @api private\r\n */\r\n\r\nSocket.prototype.onPacket = function (packet) {\r\n  if ('opening' === this.readyState || 'open' === this.readyState ||\r\n      'closing' === this.readyState) {\r\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\r\n\r\n    this.emit('packet', packet);\r\n\r\n    // Socket is live - any packet counts\r\n    this.emit('heartbeat');\r\n\r\n    switch (packet.type) {\r\n      case 'open':\r\n        this.onHandshake(JSON.parse(packet.data));\r\n        break;\r\n\r\n      case 'pong':\r\n        this.setPing();\r\n        this.emit('pong');\r\n        break;\r\n\r\n      case 'error':\r\n        var err = new Error('server error');\r\n        err.code = packet.data;\r\n        this.onError(err);\r\n        break;\r\n\r\n      case 'message':\r\n        this.emit('data', packet.data);\r\n        this.emit('message', packet.data);\r\n        break;\r\n    }\r\n  } else {\r\n    debug('packet received with socket readyState \"%s\"', this.readyState);\r\n  }\r\n};\r\n\r\n/**\r\n * Called upon handshake completion.\r\n *\r\n * @param {Object} handshake obj\r\n * @api private\r\n */\r\n\r\nSocket.prototype.onHandshake = function (data) {\r\n  this.emit('handshake', data);\r\n  this.id = data.sid;\r\n  this.transport.query.sid = data.sid;\r\n  this.upgrades = this.filterUpgrades(data.upgrades);\r\n  this.pingInterval = data.pingInterval;\r\n  this.pingTimeout = data.pingTimeout;\r\n  this.onOpen();\r\n  // In case open handler closes socket\r\n  if ('closed' === this.readyState) return;\r\n  this.setPing();\r\n\r\n  // Prolong liveness of socket on heartbeat\r\n  this.removeListener('heartbeat', this.onHeartbeat);\r\n  this.on('heartbeat', this.onHeartbeat);\r\n};\r\n\r\n/**\r\n * Resets ping timeout.\r\n *\r\n * @api private\r\n */\r\n\r\nSocket.prototype.onHeartbeat = function (timeout) {\r\n  clearTimeout(this.pingTimeoutTimer);\r\n  var self = this;\r\n  self.pingTimeoutTimer = setTimeout(function () {\r\n    if ('closed' === self.readyState) return;\r\n    self.onClose('ping timeout');\r\n  }, timeout || (self.pingInterval + self.pingTimeout));\r\n};\r\n\r\n/**\r\n * Pings server every `this.pingInterval` and expects response\r\n * within `this.pingTimeout` or closes connection.\r\n *\r\n * @api private\r\n */\r\n\r\nSocket.prototype.setPing = function () {\r\n  var self = this;\r\n  clearTimeout(self.pingIntervalTimer);\r\n  self.pingIntervalTimer = setTimeout(function () {\r\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\r\n    self.ping();\r\n    self.onHeartbeat(self.pingTimeout);\r\n  }, self.pingInterval);\r\n};\r\n\r\n/**\r\n* Sends a ping packet.\r\n*\r\n* @api private\r\n*/\r\n\r\nSocket.prototype.ping = function () {\r\n  var self = this;\r\n  this.sendPacket('ping', function () {\r\n    self.emit('ping');\r\n  });\r\n};\r\n\r\n/**\r\n * Called on `drain` event\r\n *\r\n * @api private\r\n */\r\n\r\nSocket.prototype.onDrain = function () {\r\n  this.writeBuffer.splice(0, this.prevBufferLen);\r\n\r\n  // setting prevBufferLen = 0 is very important\r\n  // for example, when upgrading, upgrade packet is sent over,\r\n  // and a nonzero prevBufferLen could cause problems on `drain`\r\n  this.prevBufferLen = 0;\r\n\r\n  if (0 === this.writeBuffer.length) {\r\n    this.emit('drain');\r\n  } else {\r\n    this.flush();\r\n  }\r\n};\r\n\r\n/**\r\n * Flush write buffers.\r\n *\r\n * @api private\r\n */\r\n\r\nSocket.prototype.flush = function () {\r\n  if ('closed' !== this.readyState && this.transport.writable &&\r\n    !this.upgrading && this.writeBuffer.length) {\r\n    debug('flushing %d packets in socket', this.writeBuffer.length);\r\n    this.transport.send(this.writeBuffer);\r\n    // keep track of current length of writeBuffer\r\n    // splice writeBuffer and callbackBuffer on `drain`\r\n    this.prevBufferLen = this.writeBuffer.length;\r\n    this.emit('flush');\r\n  }\r\n};\r\n\r\n/**\r\n * Sends a message.\r\n *\r\n * @param {String} message.\r\n * @param {Function} callback function.\r\n * @param {Object} options.\r\n * @return {Socket} for chaining.\r\n * @api public\r\n */\r\n\r\nSocket.prototype.write =\r\nSocket.prototype.send = function (msg, options, fn) {\r\n  this.sendPacket('message', msg, options, fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sends a packet.\r\n *\r\n * @param {String} packet type.\r\n * @param {String} data.\r\n * @param {Object} options.\r\n * @param {Function} callback function.\r\n * @api private\r\n */\r\n\r\nSocket.prototype.sendPacket = function (type, data, options, fn) {\r\n  if ('function' === typeof data) {\r\n    fn = data;\r\n    data = undefined;\r\n  }\r\n\r\n  if ('function' === typeof options) {\r\n    fn = options;\r\n    options = null;\r\n  }\r\n\r\n  if ('closing' === this.readyState || 'closed' === this.readyState) {\r\n    return;\r\n  }\r\n\r\n  options = options || {};\r\n  options.compress = false !== options.compress;\r\n\r\n  var packet = {\r\n    type: type,\r\n    data: data,\r\n    options: options\r\n  };\r\n  this.emit('packetCreate', packet);\r\n  this.writeBuffer.push(packet);\r\n  if (fn) this.once('flush', fn);\r\n  this.flush();\r\n};\r\n\r\n/**\r\n * Closes the connection.\r\n *\r\n * @api private\r\n */\r\n\r\nSocket.prototype.close = function () {\r\n  if ('opening' === this.readyState || 'open' === this.readyState) {\r\n    this.readyState = 'closing';\r\n\r\n    var self = this;\r\n\r\n    if (this.writeBuffer.length) {\r\n      this.once('drain', function () {\r\n        if (this.upgrading) {\r\n          waitForUpgrade();\r\n        } else {\r\n          close();\r\n        }\r\n      });\r\n    } else if (this.upgrading) {\r\n      waitForUpgrade();\r\n    } else {\r\n      close();\r\n    }\r\n  }\r\n\r\n  function close () {\r\n    self.onClose('forced close');\r\n    debug('socket closing - telling transport to close');\r\n    self.transport.close();\r\n  }\r\n\r\n  function cleanupAndClose () {\r\n    self.removeListener('upgrade', cleanupAndClose);\r\n    self.removeListener('upgradeError', cleanupAndClose);\r\n    close();\r\n  }\r\n\r\n  function waitForUpgrade () {\r\n    // wait for upgrade to finish since we can't send packets while pausing a transport\r\n    self.once('upgrade', cleanupAndClose);\r\n    self.once('upgradeError', cleanupAndClose);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Called upon transport error\r\n *\r\n * @api private\r\n */\r\n\r\nSocket.prototype.onError = function (err) {\r\n  debug('socket error %j', err);\r\n  Socket.priorWebsocketSuccess = false;\r\n  this.emit('error', err);\r\n  this.onClose('transport error', err);\r\n};\r\n\r\n/**\r\n * Called upon transport close.\r\n *\r\n * @api private\r\n */\r\n\r\nSocket.prototype.onClose = function (reason, desc) {\r\n  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {\r\n    debug('socket close with reason: \"%s\"', reason);\r\n    var self = this;\r\n\r\n    // clear timers\r\n    clearTimeout(this.pingIntervalTimer);\r\n    clearTimeout(this.pingTimeoutTimer);\r\n\r\n    // stop event from firing again for transport\r\n    this.transport.removeAllListeners('close');\r\n\r\n    // ensure transport won't stay open\r\n    this.transport.close();\r\n\r\n    // ignore further transport communication\r\n    this.transport.removeAllListeners();\r\n\r\n    // set ready state\r\n    this.readyState = 'closed';\r\n\r\n    // clear session id\r\n    this.id = null;\r\n\r\n    // emit close event\r\n    this.emit('close', reason, desc);\r\n\r\n    // clean buffers after, so users can still\r\n    // grab the buffers on `close` event\r\n    self.writeBuffer = [];\r\n    self.prevBufferLen = 0;\r\n  }\r\n};\r\n\r\n/**\r\n * Filters upgrades, returning only those matching client transports.\r\n *\r\n * @param {Array} server upgrades\r\n * @api private\r\n *\r\n */\r\n\r\nSocket.prototype.filterUpgrades = function (upgrades) {\r\n  var filteredUpgrades = [];\r\n  for (var i = 0, j = upgrades.length; i < j; i++) {\r\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\r\n  }\r\n  return filteredUpgrades;\r\n};\r\n","/**\r\n * Module dependencies\r\n */\r\n\r\nvar XMLHttpRequest = require('xmlhttprequest-ssl');\r\nvar XHR = require('./polling-xhr');\r\nvar JSONP = require('./polling-jsonp');\r\nvar websocket = require('./websocket');\r\n\r\n/**\r\n * Export transports.\r\n */\r\n\r\nexports.polling = polling;\r\nexports.websocket = websocket;\r\n\r\n/**\r\n * Polling transport polymorphic constructor.\r\n * Decides on xhr vs jsonp based on feature detection.\r\n *\r\n * @api private\r\n */\r\n\r\nfunction polling (opts) {\r\n  var xhr;\r\n  var xd = false;\r\n  var xs = false;\r\n  var jsonp = false !== opts.jsonp;\r\n\r\n  if (typeof location !== 'undefined') {\r\n    var isSSL = 'https:' === location.protocol;\r\n    var port = location.port;\r\n\r\n    // some user agents have empty `location.port`\r\n    if (!port) {\r\n      port = isSSL ? 443 : 80;\r\n    }\r\n\r\n    xd = opts.hostname !== location.hostname || port !== opts.port;\r\n    xs = opts.secure !== isSSL;\r\n  }\r\n\r\n  opts.xdomain = xd;\r\n  opts.xscheme = xs;\r\n  xhr = new XMLHttpRequest(opts);\r\n\r\n  if ('open' in xhr && !opts.forceJSONP) {\r\n    return new XHR(opts);\r\n  } else {\r\n    if (!jsonp) throw new Error('JSONP disabled');\r\n    return new JSONP(opts);\r\n  }\r\n}\r\n","/* global attachEvent */\r\n\r\n/**\r\n * Module requirements.\r\n */\r\n\r\nvar XMLHttpRequest = require('xmlhttprequest-ssl');\r\nvar Polling = require('./polling');\r\nvar Emitter = require('component-emitter');\r\nvar inherit = require('component-inherit');\r\nvar debug = require('debug')('engine.io-client:polling-xhr');\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = XHR;\r\nmodule.exports.Request = Request;\r\n\r\n/**\r\n * Empty function\r\n */\r\n\r\nfunction empty () {}\r\n\r\n/**\r\n * XHR Polling constructor.\r\n *\r\n * @param {Object} opts\r\n * @api public\r\n */\r\n\r\nfunction XHR (opts) {\r\n  Polling.call(this, opts);\r\n  this.requestTimeout = opts.requestTimeout;\r\n  this.extraHeaders = opts.extraHeaders;\r\n\r\n  if (typeof location !== 'undefined') {\r\n    var isSSL = 'https:' === location.protocol;\r\n    var port = location.port;\r\n\r\n    // some user agents have empty `location.port`\r\n    if (!port) {\r\n      port = isSSL ? 443 : 80;\r\n    }\r\n\r\n    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||\r\n      port !== opts.port;\r\n    this.xs = opts.secure !== isSSL;\r\n  }\r\n}\r\n\r\n/**\r\n * Inherits from Polling.\r\n */\r\n\r\ninherit(XHR, Polling);\r\n\r\n/**\r\n * XHR supports binary\r\n */\r\n\r\nXHR.prototype.supportsBinary = true;\r\n\r\n/**\r\n * Creates a request.\r\n *\r\n * @param {String} method\r\n * @api private\r\n */\r\n\r\nXHR.prototype.request = function (opts) {\r\n  opts = opts || {};\r\n  opts.uri = this.uri();\r\n  opts.xd = this.xd;\r\n  opts.xs = this.xs;\r\n  opts.agent = this.agent || false;\r\n  opts.supportsBinary = this.supportsBinary;\r\n  opts.enablesXDR = this.enablesXDR;\r\n  opts.withCredentials = this.withCredentials;\r\n\r\n  // SSL options for Node.js client\r\n  opts.pfx = this.pfx;\r\n  opts.key = this.key;\r\n  opts.passphrase = this.passphrase;\r\n  opts.cert = this.cert;\r\n  opts.ca = this.ca;\r\n  opts.ciphers = this.ciphers;\r\n  opts.rejectUnauthorized = this.rejectUnauthorized;\r\n  opts.requestTimeout = this.requestTimeout;\r\n\r\n  // other options for Node.js client\r\n  opts.extraHeaders = this.extraHeaders;\r\n\r\n  return new Request(opts);\r\n};\r\n\r\n/**\r\n * Sends data.\r\n *\r\n * @param {String} data to send.\r\n * @param {Function} called upon flush.\r\n * @api private\r\n */\r\n\r\nXHR.prototype.doWrite = function (data, fn) {\r\n  var isBinary = typeof data !== 'string' && data !== undefined;\r\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\r\n  var self = this;\r\n  req.on('success', fn);\r\n  req.on('error', function (err) {\r\n    self.onError('xhr post error', err);\r\n  });\r\n  this.sendXhr = req;\r\n};\r\n\r\n/**\r\n * Starts a poll cycle.\r\n *\r\n * @api private\r\n */\r\n\r\nXHR.prototype.doPoll = function () {\r\n  debug('xhr poll');\r\n  var req = this.request();\r\n  var self = this;\r\n  req.on('data', function (data) {\r\n    self.onData(data);\r\n  });\r\n  req.on('error', function (err) {\r\n    self.onError('xhr poll error', err);\r\n  });\r\n  this.pollXhr = req;\r\n};\r\n\r\n/**\r\n * Request constructor\r\n *\r\n * @param {Object} options\r\n * @api public\r\n */\r\n\r\nfunction Request (opts) {\r\n  this.method = opts.method || 'GET';\r\n  this.uri = opts.uri;\r\n  this.xd = !!opts.xd;\r\n  this.xs = !!opts.xs;\r\n  this.async = false !== opts.async;\r\n  this.data = undefined !== opts.data ? opts.data : null;\r\n  this.agent = opts.agent;\r\n  this.isBinary = opts.isBinary;\r\n  this.supportsBinary = opts.supportsBinary;\r\n  this.enablesXDR = opts.enablesXDR;\r\n  this.withCredentials = opts.withCredentials;\r\n  this.requestTimeout = opts.requestTimeout;\r\n\r\n  // SSL options for Node.js client\r\n  this.pfx = opts.pfx;\r\n  this.key = opts.key;\r\n  this.passphrase = opts.passphrase;\r\n  this.cert = opts.cert;\r\n  this.ca = opts.ca;\r\n  this.ciphers = opts.ciphers;\r\n  this.rejectUnauthorized = opts.rejectUnauthorized;\r\n\r\n  // other options for Node.js client\r\n  this.extraHeaders = opts.extraHeaders;\r\n\r\n  this.create();\r\n}\r\n\r\n/**\r\n * Mix in `Emitter`.\r\n */\r\n\r\nEmitter(Request.prototype);\r\n\r\n/**\r\n * Creates the XHR object and sends the request.\r\n *\r\n * @api private\r\n */\r\n\r\nRequest.prototype.create = function () {\r\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\r\n\r\n  // SSL options for Node.js client\r\n  opts.pfx = this.pfx;\r\n  opts.key = this.key;\r\n  opts.passphrase = this.passphrase;\r\n  opts.cert = this.cert;\r\n  opts.ca = this.ca;\r\n  opts.ciphers = this.ciphers;\r\n  opts.rejectUnauthorized = this.rejectUnauthorized;\r\n\r\n  var xhr = this.xhr = new XMLHttpRequest(opts);\r\n  var self = this;\r\n\r\n  try {\r\n    debug('xhr open %s: %s', this.method, this.uri);\r\n    xhr.open(this.method, this.uri, this.async);\r\n    try {\r\n      if (this.extraHeaders) {\r\n        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\r\n        for (var i in this.extraHeaders) {\r\n          if (this.extraHeaders.hasOwnProperty(i)) {\r\n            xhr.setRequestHeader(i, this.extraHeaders[i]);\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {}\r\n\r\n    if ('POST' === this.method) {\r\n      try {\r\n        if (this.isBinary) {\r\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\r\n        } else {\r\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\r\n        }\r\n      } catch (e) {}\r\n    }\r\n\r\n    try {\r\n      xhr.setRequestHeader('Accept', '*/*');\r\n    } catch (e) {}\r\n\r\n    // ie6 check\r\n    if ('withCredentials' in xhr) {\r\n      xhr.withCredentials = this.withCredentials;\r\n    }\r\n\r\n    if (this.requestTimeout) {\r\n      xhr.timeout = this.requestTimeout;\r\n    }\r\n\r\n    if (this.hasXDR()) {\r\n      xhr.onload = function () {\r\n        self.onLoad();\r\n      };\r\n      xhr.onerror = function () {\r\n        self.onError(xhr.responseText);\r\n      };\r\n    } else {\r\n      xhr.onreadystatechange = function () {\r\n        if (xhr.readyState === 2) {\r\n          try {\r\n            var contentType = xhr.getResponseHeader('Content-Type');\r\n            if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {\r\n              xhr.responseType = 'arraybuffer';\r\n            }\r\n          } catch (e) {}\r\n        }\r\n        if (4 !== xhr.readyState) return;\r\n        if (200 === xhr.status || 1223 === xhr.status) {\r\n          self.onLoad();\r\n        } else {\r\n          // make sure the `error` event handler that's user-set\r\n          // does not throw in the same tick and gets caught here\r\n          setTimeout(function () {\r\n            self.onError(typeof xhr.status === 'number' ? xhr.status : 0);\r\n          }, 0);\r\n        }\r\n      };\r\n    }\r\n\r\n    debug('xhr data %s', this.data);\r\n    xhr.send(this.data);\r\n  } catch (e) {\r\n    // Need to defer since .create() is called directly fhrom the constructor\r\n    // and thus the 'error' event can only be only bound *after* this exception\r\n    // occurs.  Therefore, also, we cannot throw here at all.\r\n    setTimeout(function () {\r\n      self.onError(e);\r\n    }, 0);\r\n    return;\r\n  }\r\n\r\n  if (typeof document !== 'undefined') {\r\n    this.index = Request.requestsCount++;\r\n    Request.requests[this.index] = this;\r\n  }\r\n};\r\n\r\n/**\r\n * Called upon successful response.\r\n *\r\n * @api private\r\n */\r\n\r\nRequest.prototype.onSuccess = function () {\r\n  this.emit('success');\r\n  this.cleanup();\r\n};\r\n\r\n/**\r\n * Called if we have data.\r\n *\r\n * @api private\r\n */\r\n\r\nRequest.prototype.onData = function (data) {\r\n  this.emit('data', data);\r\n  this.onSuccess();\r\n};\r\n\r\n/**\r\n * Called upon error.\r\n *\r\n * @api private\r\n */\r\n\r\nRequest.prototype.onError = function (err) {\r\n  this.emit('error', err);\r\n  this.cleanup(true);\r\n};\r\n\r\n/**\r\n * Cleans up house.\r\n *\r\n * @api private\r\n */\r\n\r\nRequest.prototype.cleanup = function (fromError) {\r\n  if ('undefined' === typeof this.xhr || null === this.xhr) {\r\n    return;\r\n  }\r\n  // xmlhttprequest\r\n  if (this.hasXDR()) {\r\n    this.xhr.onload = this.xhr.onerror = empty;\r\n  } else {\r\n    this.xhr.onreadystatechange = empty;\r\n  }\r\n\r\n  if (fromError) {\r\n    try {\r\n      this.xhr.abort();\r\n    } catch (e) {}\r\n  }\r\n\r\n  if (typeof document !== 'undefined') {\r\n    delete Request.requests[this.index];\r\n  }\r\n\r\n  this.xhr = null;\r\n};\r\n\r\n/**\r\n * Called upon load.\r\n *\r\n * @api private\r\n */\r\n\r\nRequest.prototype.onLoad = function () {\r\n  var data;\r\n  try {\r\n    var contentType;\r\n    try {\r\n      contentType = this.xhr.getResponseHeader('Content-Type');\r\n    } catch (e) {}\r\n    if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {\r\n      data = this.xhr.response || this.xhr.responseText;\r\n    } else {\r\n      data = this.xhr.responseText;\r\n    }\r\n  } catch (e) {\r\n    this.onError(e);\r\n  }\r\n  if (null != data) {\r\n    this.onData(data);\r\n  }\r\n};\r\n\r\n/**\r\n * Check if it has XDomainRequest.\r\n *\r\n * @api private\r\n */\r\n\r\nRequest.prototype.hasXDR = function () {\r\n  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;\r\n};\r\n\r\n/**\r\n * Aborts the request.\r\n *\r\n * @api public\r\n */\r\n\r\nRequest.prototype.abort = function () {\r\n  this.cleanup();\r\n};\r\n\r\n/**\r\n * Aborts pending requests when unloading the window. This is needed to prevent\r\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\r\n * emitted.\r\n */\r\n\r\nRequest.requestsCount = 0;\r\nRequest.requests = {};\r\n\r\nif (typeof document !== 'undefined') {\r\n  if (typeof attachEvent === 'function') {\r\n    attachEvent('onunload', unloadHandler);\r\n  } else if (typeof addEventListener === 'function') {\r\n    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';\r\n    addEventListener(terminationEvent, unloadHandler, false);\r\n  }\r\n}\r\n\r\nfunction unloadHandler () {\r\n  for (var i in Request.requests) {\r\n    if (Request.requests.hasOwnProperty(i)) {\r\n      Request.requests[i].abort();\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Transport = require('../transport');\r\nvar parseqs = require('parseqs');\r\nvar parser = require('engine.io-parser');\r\nvar inherit = require('component-inherit');\r\nvar yeast = require('yeast');\r\nvar debug = require('debug')('engine.io-client:polling');\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = Polling;\r\n\r\n/**\r\n * Is XHR2 supported?\r\n */\r\n\r\nvar hasXHR2 = (function () {\r\n  var XMLHttpRequest = require('xmlhttprequest-ssl');\r\n  var xhr = new XMLHttpRequest({ xdomain: false });\r\n  return null != xhr.responseType;\r\n})();\r\n\r\n/**\r\n * Polling interface.\r\n *\r\n * @param {Object} opts\r\n * @api private\r\n */\r\n\r\nfunction Polling (opts) {\r\n  var forceBase64 = (opts && opts.forceBase64);\r\n  if (!hasXHR2 || forceBase64) {\r\n    this.supportsBinary = false;\r\n  }\r\n  Transport.call(this, opts);\r\n}\r\n\r\n/**\r\n * Inherits from Transport.\r\n */\r\n\r\ninherit(Polling, Transport);\r\n\r\n/**\r\n * Transport name.\r\n */\r\n\r\nPolling.prototype.name = 'polling';\r\n\r\n/**\r\n * Opens the socket (triggers polling). We write a PING message to determine\r\n * when the transport is open.\r\n *\r\n * @api private\r\n */\r\n\r\nPolling.prototype.doOpen = function () {\r\n  this.poll();\r\n};\r\n\r\n/**\r\n * Pauses polling.\r\n *\r\n * @param {Function} callback upon buffers are flushed and transport is paused\r\n * @api private\r\n */\r\n\r\nPolling.prototype.pause = function (onPause) {\r\n  var self = this;\r\n\r\n  this.readyState = 'pausing';\r\n\r\n  function pause () {\r\n    debug('paused');\r\n    self.readyState = 'paused';\r\n    onPause();\r\n  }\r\n\r\n  if (this.polling || !this.writable) {\r\n    var total = 0;\r\n\r\n    if (this.polling) {\r\n      debug('we are currently polling - waiting to pause');\r\n      total++;\r\n      this.once('pollComplete', function () {\r\n        debug('pre-pause polling complete');\r\n        --total || pause();\r\n      });\r\n    }\r\n\r\n    if (!this.writable) {\r\n      debug('we are currently writing - waiting to pause');\r\n      total++;\r\n      this.once('drain', function () {\r\n        debug('pre-pause writing complete');\r\n        --total || pause();\r\n      });\r\n    }\r\n  } else {\r\n    pause();\r\n  }\r\n};\r\n\r\n/**\r\n * Starts polling cycle.\r\n *\r\n * @api public\r\n */\r\n\r\nPolling.prototype.poll = function () {\r\n  debug('polling');\r\n  this.polling = true;\r\n  this.doPoll();\r\n  this.emit('poll');\r\n};\r\n\r\n/**\r\n * Overloads onData to detect payloads.\r\n *\r\n * @api private\r\n */\r\n\r\nPolling.prototype.onData = function (data) {\r\n  var self = this;\r\n  debug('polling got data %s', data);\r\n  var callback = function (packet, index, total) {\r\n    // if its the first message we consider the transport open\r\n    if ('opening' === self.readyState) {\r\n      self.onOpen();\r\n    }\r\n\r\n    // if its a close packet, we close the ongoing requests\r\n    if ('close' === packet.type) {\r\n      self.onClose();\r\n      return false;\r\n    }\r\n\r\n    // otherwise bypass onData and handle the message\r\n    self.onPacket(packet);\r\n  };\r\n\r\n  // decode payload\r\n  parser.decodePayload(data, this.socket.binaryType, callback);\r\n\r\n  // if an event did not trigger closing\r\n  if ('closed' !== this.readyState) {\r\n    // if we got data we're not polling\r\n    this.polling = false;\r\n    this.emit('pollComplete');\r\n\r\n    if ('open' === this.readyState) {\r\n      this.poll();\r\n    } else {\r\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * For polling, send a close packet.\r\n *\r\n * @api private\r\n */\r\n\r\nPolling.prototype.doClose = function () {\r\n  var self = this;\r\n\r\n  function close () {\r\n    debug('writing close packet');\r\n    self.write([{ type: 'close' }]);\r\n  }\r\n\r\n  if ('open' === this.readyState) {\r\n    debug('transport open - closing');\r\n    close();\r\n  } else {\r\n    // in case we're trying to close while\r\n    // handshaking is in progress (GH-164)\r\n    debug('transport not open - deferring close');\r\n    this.once('open', close);\r\n  }\r\n};\r\n\r\n/**\r\n * Writes a packets payload.\r\n *\r\n * @param {Array} data packets\r\n * @param {Function} drain callback\r\n * @api private\r\n */\r\n\r\nPolling.prototype.write = function (packets) {\r\n  var self = this;\r\n  this.writable = false;\r\n  var callbackfn = function () {\r\n    self.writable = true;\r\n    self.emit('drain');\r\n  };\r\n\r\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\r\n    self.doWrite(data, callbackfn);\r\n  });\r\n};\r\n\r\n/**\r\n * Generates uri for connection.\r\n *\r\n * @api private\r\n */\r\n\r\nPolling.prototype.uri = function () {\r\n  var query = this.query || {};\r\n  var schema = this.secure ? 'https' : 'http';\r\n  var port = '';\r\n\r\n  // cache busting is forced\r\n  if (false !== this.timestampRequests) {\r\n    query[this.timestampParam] = yeast();\r\n  }\r\n\r\n  if (!this.supportsBinary && !query.sid) {\r\n    query.b64 = 1;\r\n  }\r\n\r\n  query = parseqs.encode(query);\r\n\r\n  // avoid port if default for schema\r\n  if (this.port && (('https' === schema && Number(this.port) !== 443) ||\r\n     ('http' === schema && Number(this.port) !== 80))) {\r\n    port = ':' + this.port;\r\n  }\r\n\r\n  // prepend ? to query\r\n  if (query.length) {\r\n    query = '?' + query;\r\n  }\r\n\r\n  var ipv6 = this.hostname.indexOf(':') !== -1;\r\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\r\n};\r\n","/**\r\n * Module dependencies.\r\n */\r\n\r\nvar parser = require('engine.io-parser');\r\nvar Emitter = require('component-emitter');\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = Transport;\r\n\r\n/**\r\n * Transport abstract constructor.\r\n *\r\n * @param {Object} options.\r\n * @api private\r\n */\r\n\r\nfunction Transport (opts) {\r\n  this.path = opts.path;\r\n  this.hostname = opts.hostname;\r\n  this.port = opts.port;\r\n  this.secure = opts.secure;\r\n  this.query = opts.query;\r\n  this.timestampParam = opts.timestampParam;\r\n  this.timestampRequests = opts.timestampRequests;\r\n  this.readyState = '';\r\n  this.agent = opts.agent || false;\r\n  this.socket = opts.socket;\r\n  this.enablesXDR = opts.enablesXDR;\r\n  this.withCredentials = opts.withCredentials;\r\n\r\n  // SSL options for Node.js client\r\n  this.pfx = opts.pfx;\r\n  this.key = opts.key;\r\n  this.passphrase = opts.passphrase;\r\n  this.cert = opts.cert;\r\n  this.ca = opts.ca;\r\n  this.ciphers = opts.ciphers;\r\n  this.rejectUnauthorized = opts.rejectUnauthorized;\r\n  this.forceNode = opts.forceNode;\r\n\r\n  // results of ReactNative environment detection\r\n  this.isReactNative = opts.isReactNative;\r\n\r\n  // other options for Node.js client\r\n  this.extraHeaders = opts.extraHeaders;\r\n  this.localAddress = opts.localAddress;\r\n}\r\n\r\n/**\r\n * Mix in `Emitter`.\r\n */\r\n\r\nEmitter(Transport.prototype);\r\n\r\n/**\r\n * Emits an error.\r\n *\r\n * @param {String} str\r\n * @return {Transport} for chaining\r\n * @api public\r\n */\r\n\r\nTransport.prototype.onError = function (msg, desc) {\r\n  var err = new Error(msg);\r\n  err.type = 'TransportError';\r\n  err.description = desc;\r\n  this.emit('error', err);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Opens the transport.\r\n *\r\n * @api public\r\n */\r\n\r\nTransport.prototype.open = function () {\r\n  if ('closed' === this.readyState || '' === this.readyState) {\r\n    this.readyState = 'opening';\r\n    this.doOpen();\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Closes the transport.\r\n *\r\n * @api private\r\n */\r\n\r\nTransport.prototype.close = function () {\r\n  if ('opening' === this.readyState || 'open' === this.readyState) {\r\n    this.doClose();\r\n    this.onClose();\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sends multiple packets.\r\n *\r\n * @param {Array} packets\r\n * @api private\r\n */\r\n\r\nTransport.prototype.send = function (packets) {\r\n  if ('open' === this.readyState) {\r\n    this.write(packets);\r\n  } else {\r\n    throw new Error('Transport not open');\r\n  }\r\n};\r\n\r\n/**\r\n * Called upon open\r\n *\r\n * @api private\r\n */\r\n\r\nTransport.prototype.onOpen = function () {\r\n  this.readyState = 'open';\r\n  this.writable = true;\r\n  this.emit('open');\r\n};\r\n\r\n/**\r\n * Called with data.\r\n *\r\n * @param {String} data\r\n * @api private\r\n */\r\n\r\nTransport.prototype.onData = function (data) {\r\n  var packet = parser.decodePacket(data, this.socket.binaryType);\r\n  this.onPacket(packet);\r\n};\r\n\r\n/**\r\n * Called with a decoded packet.\r\n */\r\n\r\nTransport.prototype.onPacket = function (packet) {\r\n  this.emit('packet', packet);\r\n};\r\n\r\n/**\r\n * Called upon close.\r\n *\r\n * @api private\r\n */\r\n\r\nTransport.prototype.onClose = function () {\r\n  this.readyState = 'closed';\r\n  this.emit('close');\r\n};\r\n","/**\r\n * Module requirements.\r\n */\r\n\r\nvar Polling = require('./polling');\r\nvar inherit = require('component-inherit');\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = JSONPPolling;\r\n\r\n/**\r\n * Cached regular expressions.\r\n */\r\n\r\nvar rNewline = /\\n/g;\r\nvar rEscapedNewline = /\\\\n/g;\r\n\r\n/**\r\n * Global JSONP callbacks.\r\n */\r\n\r\nvar callbacks;\r\n\r\n/**\r\n * Noop.\r\n */\r\n\r\nfunction empty () { }\r\n\r\n/**\r\n * Until https://github.com/tc39/proposal-global is shipped.\r\n */\r\nfunction glob () {\r\n  return typeof self !== 'undefined' ? self\r\n      : typeof window !== 'undefined' ? window\r\n      : typeof global !== 'undefined' ? global : {};\r\n}\r\n\r\n/**\r\n * JSONP Polling constructor.\r\n *\r\n * @param {Object} opts.\r\n * @api public\r\n */\r\n\r\nfunction JSONPPolling (opts) {\r\n  Polling.call(this, opts);\r\n\r\n  this.query = this.query || {};\r\n\r\n  // define global callbacks array if not present\r\n  // we do this here (lazily) to avoid unneeded global pollution\r\n  if (!callbacks) {\r\n    // we need to consider multiple engines in the same page\r\n    var global = glob();\r\n    callbacks = global.___eio = (global.___eio || []);\r\n  }\r\n\r\n  // callback identifier\r\n  this.index = callbacks.length;\r\n\r\n  // add callback to jsonp global\r\n  var self = this;\r\n  callbacks.push(function (msg) {\r\n    self.onData(msg);\r\n  });\r\n\r\n  // append to query string\r\n  this.query.j = this.index;\r\n\r\n  // prevent spurious errors from being emitted when the window is unloaded\r\n  if (typeof addEventListener === 'function') {\r\n    addEventListener('beforeunload', function () {\r\n      if (self.script) self.script.onerror = empty;\r\n    }, false);\r\n  }\r\n}\r\n\r\n/**\r\n * Inherits from Polling.\r\n */\r\n\r\ninherit(JSONPPolling, Polling);\r\n\r\n/*\r\n * JSONP only supports binary as base64 encoded strings\r\n */\r\n\r\nJSONPPolling.prototype.supportsBinary = false;\r\n\r\n/**\r\n * Closes the socket.\r\n *\r\n * @api private\r\n */\r\n\r\nJSONPPolling.prototype.doClose = function () {\r\n  if (this.script) {\r\n    this.script.parentNode.removeChild(this.script);\r\n    this.script = null;\r\n  }\r\n\r\n  if (this.form) {\r\n    this.form.parentNode.removeChild(this.form);\r\n    this.form = null;\r\n    this.iframe = null;\r\n  }\r\n\r\n  Polling.prototype.doClose.call(this);\r\n};\r\n\r\n/**\r\n * Starts a poll cycle.\r\n *\r\n * @api private\r\n */\r\n\r\nJSONPPolling.prototype.doPoll = function () {\r\n  var self = this;\r\n  var script = document.createElement('script');\r\n\r\n  if (this.script) {\r\n    this.script.parentNode.removeChild(this.script);\r\n    this.script = null;\r\n  }\r\n\r\n  script.async = true;\r\n  script.src = this.uri();\r\n  script.onerror = function (e) {\r\n    self.onError('jsonp poll error', e);\r\n  };\r\n\r\n  var insertAt = document.getElementsByTagName('script')[0];\r\n  if (insertAt) {\r\n    insertAt.parentNode.insertBefore(script, insertAt);\r\n  } else {\r\n    (document.head || document.body).appendChild(script);\r\n  }\r\n  this.script = script;\r\n\r\n  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);\r\n\r\n  if (isUAgecko) {\r\n    setTimeout(function () {\r\n      var iframe = document.createElement('iframe');\r\n      document.body.appendChild(iframe);\r\n      document.body.removeChild(iframe);\r\n    }, 100);\r\n  }\r\n};\r\n\r\n/**\r\n * Writes with a hidden iframe.\r\n *\r\n * @param {String} data to send\r\n * @param {Function} called upon flush.\r\n * @api private\r\n */\r\n\r\nJSONPPolling.prototype.doWrite = function (data, fn) {\r\n  var self = this;\r\n\r\n  if (!this.form) {\r\n    var form = document.createElement('form');\r\n    var area = document.createElement('textarea');\r\n    var id = this.iframeId = 'eio_iframe_' + this.index;\r\n    var iframe;\r\n\r\n    form.className = 'socketio';\r\n    form.style.position = 'absolute';\r\n    form.style.top = '-1000px';\r\n    form.style.left = '-1000px';\r\n    form.target = id;\r\n    form.method = 'POST';\r\n    form.setAttribute('accept-charset', 'utf-8');\r\n    area.name = 'd';\r\n    form.appendChild(area);\r\n    document.body.appendChild(form);\r\n\r\n    this.form = form;\r\n    this.area = area;\r\n  }\r\n\r\n  this.form.action = this.uri();\r\n\r\n  function complete () {\r\n    initIframe();\r\n    fn();\r\n  }\r\n\r\n  function initIframe () {\r\n    if (self.iframe) {\r\n      try {\r\n        self.form.removeChild(self.iframe);\r\n      } catch (e) {\r\n        self.onError('jsonp polling iframe removal error', e);\r\n      }\r\n    }\r\n\r\n    try {\r\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\r\n      var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\r\n      iframe = document.createElement(html);\r\n    } catch (e) {\r\n      iframe = document.createElement('iframe');\r\n      iframe.name = self.iframeId;\r\n      iframe.src = 'javascript:0';\r\n    }\r\n\r\n    iframe.id = self.iframeId;\r\n\r\n    self.form.appendChild(iframe);\r\n    self.iframe = iframe;\r\n  }\r\n\r\n  initIframe();\r\n\r\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\r\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\r\n  data = data.replace(rEscapedNewline, '\\\\\\n');\r\n  this.area.value = data.replace(rNewline, '\\\\n');\r\n\r\n  try {\r\n    this.form.submit();\r\n  } catch (e) {}\r\n\r\n  if (this.iframe.attachEvent) {\r\n    this.iframe.onreadystatechange = function () {\r\n      if (self.iframe.readyState === 'complete') {\r\n        complete();\r\n      }\r\n    };\r\n  } else {\r\n    this.iframe.onload = complete;\r\n  }\r\n};\r\n","/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Transport = require('../transport');\r\nvar parser = require('engine.io-parser');\r\nvar parseqs = require('parseqs');\r\nvar inherit = require('component-inherit');\r\nvar yeast = require('yeast');\r\nvar debug = require('debug')('engine.io-client:websocket');\r\n\r\nvar BrowserWebSocket, NodeWebSocket;\r\n\r\nif (typeof WebSocket !== 'undefined') {\r\n  BrowserWebSocket = WebSocket;\r\n} else if (typeof self !== 'undefined') {\r\n  BrowserWebSocket = self.WebSocket || self.MozWebSocket;\r\n}\r\n\r\nif (typeof window === 'undefined') {\r\n  try {\r\n    NodeWebSocket = require('ws');\r\n  } catch (e) { }\r\n}\r\n\r\n/**\r\n * Get either the `WebSocket` or `MozWebSocket` globals\r\n * in the browser or try to resolve WebSocket-compatible\r\n * interface exposed by `ws` for Node-like environment.\r\n */\r\n\r\nvar WebSocketImpl = BrowserWebSocket || NodeWebSocket;\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = WS;\r\n\r\n/**\r\n * WebSocket transport constructor.\r\n *\r\n * @api {Object} connection options\r\n * @api public\r\n */\r\n\r\nfunction WS (opts) {\r\n  var forceBase64 = (opts && opts.forceBase64);\r\n  if (forceBase64) {\r\n    this.supportsBinary = false;\r\n  }\r\n  this.perMessageDeflate = opts.perMessageDeflate;\r\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\r\n  this.protocols = opts.protocols;\r\n  if (!this.usingBrowserWebSocket) {\r\n    WebSocketImpl = NodeWebSocket;\r\n  }\r\n  Transport.call(this, opts);\r\n}\r\n\r\n/**\r\n * Inherits from Transport.\r\n */\r\n\r\ninherit(WS, Transport);\r\n\r\n/**\r\n * Transport name.\r\n *\r\n * @api public\r\n */\r\n\r\nWS.prototype.name = 'websocket';\r\n\r\n/*\r\n * WebSockets support binary\r\n */\r\n\r\nWS.prototype.supportsBinary = true;\r\n\r\n/**\r\n * Opens socket.\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.doOpen = function () {\r\n  if (!this.check()) {\r\n    // let probe timeout\r\n    return;\r\n  }\r\n\r\n  var uri = this.uri();\r\n  var protocols = this.protocols;\r\n  var opts = {\r\n    agent: this.agent,\r\n    perMessageDeflate: this.perMessageDeflate\r\n  };\r\n\r\n  // SSL options for Node.js client\r\n  opts.pfx = this.pfx;\r\n  opts.key = this.key;\r\n  opts.passphrase = this.passphrase;\r\n  opts.cert = this.cert;\r\n  opts.ca = this.ca;\r\n  opts.ciphers = this.ciphers;\r\n  opts.rejectUnauthorized = this.rejectUnauthorized;\r\n  if (this.extraHeaders) {\r\n    opts.headers = this.extraHeaders;\r\n  }\r\n  if (this.localAddress) {\r\n    opts.localAddress = this.localAddress;\r\n  }\r\n\r\n  try {\r\n    this.ws =\r\n      this.usingBrowserWebSocket && !this.isReactNative\r\n        ? protocols\r\n          ? new WebSocketImpl(uri, protocols)\r\n          : new WebSocketImpl(uri)\r\n        : new WebSocketImpl(uri, protocols, opts);\r\n  } catch (err) {\r\n    return this.emit('error', err);\r\n  }\r\n\r\n  if (this.ws.binaryType === undefined) {\r\n    this.supportsBinary = false;\r\n  }\r\n\r\n  if (this.ws.supports && this.ws.supports.binary) {\r\n    this.supportsBinary = true;\r\n    this.ws.binaryType = 'nodebuffer';\r\n  } else {\r\n    this.ws.binaryType = 'arraybuffer';\r\n  }\r\n\r\n  this.addEventListeners();\r\n};\r\n\r\n/**\r\n * Adds event listeners to the socket\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.addEventListeners = function () {\r\n  var self = this;\r\n\r\n  this.ws.onopen = function () {\r\n    self.onOpen();\r\n  };\r\n  this.ws.onclose = function () {\r\n    self.onClose();\r\n  };\r\n  this.ws.onmessage = function (ev) {\r\n    self.onData(ev.data);\r\n  };\r\n  this.ws.onerror = function (e) {\r\n    self.onError('websocket error', e);\r\n  };\r\n};\r\n\r\n/**\r\n * Writes data to socket.\r\n *\r\n * @param {Array} array of packets.\r\n * @api private\r\n */\r\n\r\nWS.prototype.write = function (packets) {\r\n  var self = this;\r\n  this.writable = false;\r\n\r\n  // encodePacket efficient as it uses WS framing\r\n  // no need for encodePayload\r\n  var total = packets.length;\r\n  for (var i = 0, l = total; i < l; i++) {\r\n    (function (packet) {\r\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\r\n        if (!self.usingBrowserWebSocket) {\r\n          // always create a new object (GH-437)\r\n          var opts = {};\r\n          if (packet.options) {\r\n            opts.compress = packet.options.compress;\r\n          }\r\n\r\n          if (self.perMessageDeflate) {\r\n            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;\r\n            if (len < self.perMessageDeflate.threshold) {\r\n              opts.compress = false;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Sometimes the websocket has already been closed but the browser didn't\r\n        // have a chance of informing us about it yet, in that case send will\r\n        // throw an error\r\n        try {\r\n          if (self.usingBrowserWebSocket) {\r\n            // TypeError is thrown when passing the second argument on Safari\r\n            self.ws.send(data);\r\n          } else {\r\n            self.ws.send(data, opts);\r\n          }\r\n        } catch (e) {\r\n          debug('websocket closed before onclose event');\r\n        }\r\n\r\n        --total || done();\r\n      });\r\n    })(packets[i]);\r\n  }\r\n\r\n  function done () {\r\n    self.emit('flush');\r\n\r\n    // fake drain\r\n    // defer to next tick to allow Socket to clear writeBuffer\r\n    setTimeout(function () {\r\n      self.writable = true;\r\n      self.emit('drain');\r\n    }, 0);\r\n  }\r\n};\r\n\r\n/**\r\n * Called upon close\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.onClose = function () {\r\n  Transport.prototype.onClose.call(this);\r\n};\r\n\r\n/**\r\n * Closes socket.\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.doClose = function () {\r\n  if (typeof this.ws !== 'undefined') {\r\n    this.ws.close();\r\n  }\r\n};\r\n\r\n/**\r\n * Generates uri for connection.\r\n *\r\n * @api private\r\n */\r\n\r\nWS.prototype.uri = function () {\r\n  var query = this.query || {};\r\n  var schema = this.secure ? 'wss' : 'ws';\r\n  var port = '';\r\n\r\n  // avoid port if default for schema\r\n  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\r\n    ('ws' === schema && Number(this.port) !== 80))) {\r\n    port = ':' + this.port;\r\n  }\r\n\r\n  // append timestamp to URI\r\n  if (this.timestampRequests) {\r\n    query[this.timestampParam] = yeast();\r\n  }\r\n\r\n  // communicate binary support capabilities\r\n  if (!this.supportsBinary) {\r\n    query.b64 = 1;\r\n  }\r\n\r\n  query = parseqs.encode(query);\r\n\r\n  // prepend ? to query\r\n  if (query.length) {\r\n    query = '?' + query;\r\n  }\r\n\r\n  var ipv6 = this.hostname.indexOf(':') !== -1;\r\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\r\n};\r\n\r\n/**\r\n * Feature detection for WebSocket.\r\n *\r\n * @return {Boolean} whether this transport is available.\r\n * @api public\r\n */\r\n\r\nWS.prototype.check = function () {\r\n  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);\r\n};\r\n"]}